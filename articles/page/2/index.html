<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Articles | 블로그</title>
<meta name=keywords content><meta name=description content="Articles - 블로그"><meta name=author content><link rel=canonical href=https://leeyeonseong.github.io/tech-blog/articles/><link crossorigin=anonymous href=/tech-blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://leeyeonseong.github.io/tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://leeyeonseong.github.io/tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leeyeonseong.github.io/tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://leeyeonseong.github.io/tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://leeyeonseong.github.io/tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://leeyeonseong.github.io/tech-blog/articles/index.xml><link rel=alternate hreflang=en href=https://leeyeonseong.github.io/tech-blog/articles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://leeyeonseong.github.io/tech-blog/articles/"><meta property="og:site_name" content="블로그"><meta property="og:title" content="Articles"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Articles"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://leeyeonseong.github.io/tech-blog/articles/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leeyeonseong.github.io/tech-blog/ accesskey=h title="블로그 (Alt + H)">블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leeyeonseong.github.io/tech-blog/articles/ title=Articles><span class=active>Articles</span></a></li><li><a href=https://leeyeonseong.github.io/tech-blog/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Articles</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?</h2></header><div class=entry-content><p>연결 단계에서 발견된 간헐적 연결 문제 WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.
const peerConnection = new RTCPeerConnection({ iceServers: [{ urls: "example.google.com:19302" }], }); peerConnection.onicecandidate = (event) => { if (event.candidate) { socket.emit("ice-candidate", event.candidate); } }; peerConnection .createOffer() .then((offer) => peerConnection.setLocalDescription(offer)) .then(() => { socket.emit("offer", peerConnection.localDescription); }); 해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:
영상이 연결되지 않거나 상대가 보이지 않음 상태 동기화나 메시지 수신이 실패함 네트워크 문제인지 브라우저 문제인지 식별하기 어려움 사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌 📌 VPN 사용 환경에서의 연결 실패 또한 일부 사용자들이 VPN을 활성화한 상태에서 접속하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.
...</p></div><footer class=entry-footer><span title='2023-05-03 00:00:00 +0000 UTC'>May 3, 2023</span></footer><a class=entry-link aria-label="post link to 해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?" href=https://leeyeonseong.github.io/tech-blog/articles/socket-issue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Context API 대신 React Query를 선택한 이유</h2></header><div class=entry-content><p>이전 글에서 Recoil 활용해 클라이언트 상태를 정리했던 이야기를 남긴 적이 있다.
이번에는 같은 프로젝트 내에서 서버 상태를 다루는 방식에 대해 정리해보려 한다.
Context API를 빠르게 선택했던 이유 처음 프로젝트를 시작할 때는 아주 간단한 요구사항만 있었기 때문에, 굳이 무거운 상태 관리 라이브러리를 도입하지 않고 Context API만으로 충분하다고 판단했다.
속도를 중시한 결정이었다. 실제로 빠르게 결과물을 만들 수 있었고, 배포도 문제없이 진행됐다.
하지만 이후 사업이 확장되며 기능이 하나씩 추가되기 시작했고, 그때부터 context 구조가 무겁게 느껴지기 시작했다.
추가되는 context마다 리렌더링 범위가 넓어졌고, UI 단위에서만 필요한 데이터까지 전역에 얹히는 구조가 되었다.
...</p></div><footer class=entry-footer><span title='2023-04-28 00:00:00 +0000 UTC'>April 28, 2023</span></footer><a class=entry-link aria-label="post link to Context API 대신 React Query를 선택한 이유" href=https://leeyeonseong.github.io/tech-blog/articles/react-query-migration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WebRTC howling ...</h2></header><div class=entry-content><p>하울링은 왜 생기는가? 하울링은 간단히 말하면, 자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고,
그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.
WebRTC는 getUserMedia로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.
여러 방법을 시도해봤습니다 처음에는 아래와 같은 해결책들을 시도했습니다:
연결 직후 마이크를 자동으로 mute 처리 local stream과 remote stream을 분리해 렌더링 오디오 트랙만 따로 추적해서 제어 &lt;audio muted /> 설정 (그러나 의도대로 안 되는 경우도 많음) 하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다.
...</p></div><footer class=entry-footer><span title='2023-04-03 00:00:00 +0000 UTC'>April 3, 2023</span></footer><a class=entry-link aria-label="post link to WebRTC howling ..." href=https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>클라이언트와 서버 상태, 왜 분리했는가?</h2></header><div class=entry-content><p>프로젝트를 진행하다 보면 어느 순간 상태가 복잡해지기 시작합니다.
처음에는 간단한 기능만 있어서 Context API로도 충분해 보였고, 그렇게 빠르게 개발을 시작했습니다.
하지만 기능이 늘어나고 화면과 상태의 연동이 많아지면서, 상태 관리 구조에 대한 고민이 본격적으로 생겼습니다.
Context API에서 발생한 문제 Context는 간단하고 직관적인 구조라는 점에서 좋지만, 하나의 상태가 바뀌면 해당 Provider 아래의 모든 컴포넌트가 함께 리렌더링되는 특성이 있습니다.
이 문제를 해결하기 위해 Provider를 잘게 쪼개는 방식으로 대응해보기도 했습니다.
하지만 상태가 많아지고, 각각의 의존성을 분리해야 하는 상황에서는 점점 코드가 복잡해졌습니다.
...</p></div><footer class=entry-footer><span title='2023-03-24 00:00:00 +0000 UTC'>March 24, 2023</span></footer><a class=entry-link aria-label="post link to 클라이언트와 서버 상태, 왜 분리했는가?" href=https://leeyeonseong.github.io/tech-blog/articles/client-server-state/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WebRTC 사용 중 발생하는 발열과 성능 저하</h2></header><div class=entry-content><p>영상 연결 시스템을 다루다 보면 브라우저, 특히 모바일에서 영상 연결이 오래 지속될 경우
발열, 화면 멈춤, 느려짐 같은 현상이 발생하는 걸 종종 볼 수 있다.
그동안은 “기기 문제겠지”라고 넘겼지만,
WebRTC 내부 구조가 어떻게 작동하는지, 왜 그런 문제가 생기는지 공부해보기로 했다.
WebRTC에서 발열/성능 저하가 발생하는 구조 찾아보면서 아래와 같은 지점에서 성능 이슈가 발생할 수 있다는 걸 알게 되었다:
1. getUserMedia 호출 시 고해상도 요청 기본 요청은 HD(1280x720) 이상일 수 있음 모바일에서 고해상도는 CPU와 배터리 부담이 큼 // 적절한 해상도 지정 navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 360, frameRate: 15 }, audio: true, }); 고해상도 + 고 FPS → 모바일 발열 발생 가능성 ↑
...</p></div><footer class=entry-footer><span title='2022-11-12 00:00:00 +0000 UTC'>November 12, 2022</span></footer><a class=entry-link aria-label="post link to WebRTC 사용 중 발생하는 발열과 성능 저하" href=https://leeyeonseong.github.io/tech-blog/articles/webrtc-codec/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://leeyeonseong.github.io/tech-blog/articles/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://leeyeonseong.github.io/tech-blog/>블로그</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>