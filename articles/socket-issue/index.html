<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까? | 블로그</title>
<meta name=keywords content="Socket.io,네트워크 안정성"><meta name=description content='연결 단계에서 발견된 간헐적 연결 문제
WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.
const peerConnection = new RTCPeerConnection({
  iceServers: [{ urls: "example.google.com:19302" }],
});

peerConnection.onicecandidate = (event) => {
  if (event.candidate) {
    socket.emit("ice-candidate", event.candidate);
  }
};

peerConnection
  .createOffer()
  .then((offer) => peerConnection.setLocalDescription(offer))
  .then(() => {
    socket.emit("offer", peerConnection.localDescription);
  });
해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:

영상이 연결되지 않거나 상대가 보이지 않음
상태 동기화나 메시지 수신이 실패함
네트워크 문제인지 브라우저 문제인지 식별하기 어려움
사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌

📌 VPN 사용 환경에서의 연결 실패
또한 일부 사용자들이 VPN을 활성화한 상태에서 접속하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.'><meta name=author content><link rel=canonical href=https://leeyeonseong.github.io/tech-blog/articles/socket-issue/><link crossorigin=anonymous href=/tech-blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://leeyeonseong.github.io/tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://leeyeonseong.github.io/tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leeyeonseong.github.io/tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://leeyeonseong.github.io/tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://leeyeonseong.github.io/tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://leeyeonseong.github.io/tech-blog/articles/socket-issue/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://leeyeonseong.github.io/tech-blog/articles/socket-issue/"><meta property="og:site_name" content="블로그"><meta property="og:title" content="해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?"><meta property="og:description" content='연결 단계에서 발견된 간헐적 연결 문제 WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.
const peerConnection = new RTCPeerConnection({ iceServers: [{ urls: "example.google.com:19302" }], }); peerConnection.onicecandidate = (event) => { if (event.candidate) { socket.emit("ice-candidate", event.candidate); } }; peerConnection .createOffer() .then((offer) => peerConnection.setLocalDescription(offer)) .then(() => { socket.emit("offer", peerConnection.localDescription); }); 해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:
영상이 연결되지 않거나 상대가 보이지 않음 상태 동기화나 메시지 수신이 실패함 네트워크 문제인지 브라우저 문제인지 식별하기 어려움 사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌 📌 VPN 사용 환경에서의 연결 실패 또한 일부 사용자들이 VPN을 활성화한 상태에서 접속하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.'><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2023-05-03T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-03T00:00:00+00:00"><meta property="article:tag" content="Socket.io"><meta property="article:tag" content="네트워크 안정성"><meta name=twitter:card content="summary"><meta name=twitter:title content="해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?"><meta name=twitter:description content='연결 단계에서 발견된 간헐적 연결 문제
WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.
const peerConnection = new RTCPeerConnection({
  iceServers: [{ urls: "example.google.com:19302" }],
});

peerConnection.onicecandidate = (event) => {
  if (event.candidate) {
    socket.emit("ice-candidate", event.candidate);
  }
};

peerConnection
  .createOffer()
  .then((offer) => peerConnection.setLocalDescription(offer))
  .then(() => {
    socket.emit("offer", peerConnection.localDescription);
  });
해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:

영상이 연결되지 않거나 상대가 보이지 않음
상태 동기화나 메시지 수신이 실패함
네트워크 문제인지 브라우저 문제인지 식별하기 어려움
사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌

📌 VPN 사용 환경에서의 연결 실패
또한 일부 사용자들이 VPN을 활성화한 상태에서 접속하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://leeyeonseong.github.io/tech-blog/articles/"},{"@type":"ListItem","position":2,"name":"해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?","item":"https://leeyeonseong.github.io/tech-blog/articles/socket-issue/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?","name":"해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?","description":"연결 단계에서 발견된 간헐적 연결 문제 WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.\nconst peerConnection = new RTCPeerConnection({ iceServers: [{ urls: \u0026#34;example.google.com:19302\u0026#34; }], }); peerConnection.onicecandidate = (event) =\u0026gt; { if (event.candidate) { socket.emit(\u0026#34;ice-candidate\u0026#34;, event.candidate); } }; peerConnection .createOffer() .then((offer) =\u0026gt; peerConnection.setLocalDescription(offer)) .then(() =\u0026gt; { socket.emit(\u0026#34;offer\u0026#34;, peerConnection.localDescription); }); 해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:\n영상이 연결되지 않거나 상대가 보이지 않음 상태 동기화나 메시지 수신이 실패함 네트워크 문제인지 브라우저 문제인지 식별하기 어려움 사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌 📌 VPN 사용 환경에서의 연결 실패 또한 일부 사용자들이 VPN을 활성화한 상태에서 접속하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.\n","keywords":["Socket.io","네트워크 안정성"],"articleBody":"연결 단계에서 발견된 간헐적 연결 문제 WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.\nconst peerConnection = new RTCPeerConnection({ iceServers: [{ urls: \"example.google.com:19302\" }], }); peerConnection.onicecandidate = (event) =\u003e { if (event.candidate) { socket.emit(\"ice-candidate\", event.candidate); } }; peerConnection .createOffer() .then((offer) =\u003e peerConnection.setLocalDescription(offer)) .then(() =\u003e { socket.emit(\"offer\", peerConnection.localDescription); }); 해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:\n영상이 연결되지 않거나 상대가 보이지 않음 상태 동기화나 메시지 수신이 실패함 네트워크 문제인지 브라우저 문제인지 식별하기 어려움 사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌 📌 VPN 사용 환경에서의 연결 실패 또한 일부 사용자들이 VPN을 활성화한 상태에서 접속하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.\n이 경우 STUN 서버가 공인 IP를 제대로 파악하지 못하거나,\nVPN이 UDP 및 P2P 트래픽을 제한하는 경우가 많아 ICE candidate 수집 자체가 실패할 수 있다.\n// ICE candidate 로그 분석으로 VPN 의심 환경 확인 peerConnection.onicecandidate = (event) =\u003e { if (event.candidate) { const cand = event.candidate.candidate; if (cand.includes(\"relay\")) { console.log( \"VPN 또는 제한된 네트워크일 경우 설정에서 VPN 기능을 끄고 사용하시길 권장합니다.\", ); } else if (cand.includes(\"host\")) { console.log(\"직접 연결(host candidate)\"); } } else { console.log(\"ICE candidate 수집 종료\"); } }; 프론트엔드에서는 이를 직접 감지할 수는 없지만,\n연결 실패 시 “VPN이 켜져 있다면 확인해 주세요\"라는 안내 메시지를 추가함으로써\n사용자 혼란을 줄이는 데 도움이 되었다.\n이 문제를 계기로, 연결 상태에 대한 진단 및 복원 전략을 설계하게 되었다.\n전략: 테스트 영상 연결 시스템 구축 영상 연결 시작 전, 네트워크 상태를 점검할 수 있는 별도의 테스트 연결 시스템을 구축했다.\n목표는 단순했다: 사용자 측의 네트워크가 WebRTC 연결에 적합한지 사전 진단 연결이 정상인지 아닌지를 눈으로 확인할 수 있는 구조 실패 시, 관리자가 사전 대응(재접속 유도, 전화 연결 등)을 할 수 있도록 Socket.IO로 연결 상태 추적 WebRTC의 연결 여부 자체는 API만으로 감지하기 어렵기 때문에,\n우리는 WebRTC 연결과 함께 Socket.IO를 통해 연결 상태를 판단했다.\n// useSocket.ts const socket = io(SOCKET_URL, { reconnection: true, reconnectionAttempts: 5, // 5회까지 재시도 reconnectionDelay: 3000, // 3초 간격 timeout: 8000, // 연결 시도 제한 시간 8초 }); useEffect(() =\u003e { socket.on(\"connect\", () =\u003e { setStatus(\"connected\"); }); socket.on(\"disconnect\", () =\u003e { setStatus(\"disconnected\"); }); socket.on(\"reconnecting\", () =\u003e { setStatus(\"reconnecting\"); }); socket.on(\"connect_error\", () =\u003e { setStatus(\"error\"); }); }, []); 이 이벤트 흐름을 통해 연결이 끊겼는지, 재시도 중인지, 정상 연결되었는지를 클라이언트에서 실시간으로 인지할 수 있었다.\n연결 상태를 UI로 시각화 우리는 단순한 문자열 표시가 아닌, 직관적인 색상 원형 표시를 사용해 네트워크 상태를 표현했다.\n// Indicator.tsx import React from \"react\"; import styled from \"styled-components\"; type Status = \"connected\" | \"reconnecting\" | \"disconnected\" | \"error\"; interface IIndicatorTypeProps { status: Status; } const statusColorMap: Record\u003cStatus, string\u003e = { connected: \"#4CAF50\", // green reconnecting: \"#FFEB3B\", // yellow disconnected: \"#F44336\", // red error: \"#9E9E9E\", // gray }; const Dot = styled.div\u003c{ color: string }\u003e` width: 10px; height: 10px; border-radius: 50%; background-color: ${({ color }) =\u003e color}; margin-right: 8px; `; const Indicator: React.FC\u003cIIndicatorTypeProps\u003e = ({ status }) =\u003e { return \u003cDot color={statusColorMap[status]} /\u003e; }; export default Indicator; 이러한 UI는 사용자 또는 관리자가 한눈에 상황을 파악할 수 있도록 해주었고,\n사용자에게도 “지금 연결이 안 되고 있다\"는 명확한 피드백을 제공해 UX 혼란을 줄일 수 있었다.\n재연결 로직 및 수동 재시도 Socket.IO는 자동 reconnect 기능을 제공하지만,\n간헐적인 실패에 대비하여 수동 재시도 버튼도 함께 제공했다.\n{ status === \"disconnected\" \u0026\u0026 ( \u003cbutton onClick={manualReconnect}\u003e다시 연결 시도\u003c/button\u003e ); } 이때 manualReconnect 함수는 내부적으로 소켓과 WebRTC 스트림을 초기화한 뒤, 화면을 다시 렌더링하며 재연결을 시도했다.\n시스템 적용 이후의 변화 이 테스트 시스템 도입 후, 다음과 같은 개선이 있었다:\n연결 실패율이 감소했고, 실패 시 사전 감지가 가능해짐 연결 문제에 대한 피드백이 시각적으로 제공되어 UX 혼란이 줄어듦 담당자와 사용자 모두가 상태 인지 → 대처 흐름을 이해하기 쉬워짐 마무리하며 WebRTC는 네트워크 품질과 연결 상태에 큰 영향을 받는다.\n특히 해외 사용자 대상의 시스템에서는 환경이 예측 불가했기 때문에,\n연결 실패 자체보다도 실패했는지 조차 모르는 상황이 더 큰 문제였다.\nSocket.IO와 간단한 연결 UI를 기반으로 한 이 테스트 시스템은\nWebRTC 인프라를 보완하지 않고도 문제를 조기에 감지하고 대응할 수 있는 프론트엔드 측 해결책이었다.\n","wordCount":"630","inLanguage":"en","datePublished":"2023-05-03T00:00:00Z","dateModified":"2023-05-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyeonseong.github.io/tech-blog/articles/socket-issue/"},"publisher":{"@type":"Organization","name":"블로그","logo":{"@type":"ImageObject","url":"https://leeyeonseong.github.io/tech-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leeyeonseong.github.io/tech-blog/ accesskey=h title="블로그 (Alt + H)">블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leeyeonseong.github.io/tech-blog/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://leeyeonseong.github.io/tech-blog/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?</h1><div class=post-meta><span title='2023-05-03 00:00:00 +0000 UTC'>May 3, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%97%b0%ea%b2%b0-%eb%8b%a8%ea%b3%84%ec%97%90%ec%84%9c-%eb%b0%9c%ea%b2%ac%eb%90%9c-%ea%b0%84%ed%97%90%ec%a0%81-%ec%97%b0%ea%b2%b0-%eb%ac%b8%ec%a0%9c aria-label="연결 단계에서 발견된 간헐적 연결 문제">연결 단계에서 발견된 간헐적 연결 문제</a><ul><li><a href=#-vpn-%ec%82%ac%ec%9a%a9-%ed%99%98%ea%b2%bd%ec%97%90%ec%84%9c%ec%9d%98-%ec%97%b0%ea%b2%b0-%ec%8b%a4%ed%8c%a8 aria-label="📌 VPN 사용 환경에서의 연결 실패">📌 VPN 사용 환경에서의 연결 실패</a></li></ul></li><li><a href=#%ec%a0%84%eb%9e%b5-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%98%81%ec%83%81-%ec%97%b0%ea%b2%b0-%ec%8b%9c%ec%8a%a4%ed%85%9c-%ea%b5%ac%ec%b6%95 aria-label="전략: 테스트 영상 연결 시스템 구축">전략: 테스트 영상 연결 시스템 구축</a><ul><li><a href=#%eb%aa%a9%ed%91%9c%eb%8a%94-%eb%8b%a8%ec%88%9c%ed%96%88%eb%8b%a4 aria-label="목표는 단순했다:">목표는 단순했다:</a></li></ul></li><li><a href=#socketio%eb%a1%9c-%ec%97%b0%ea%b2%b0-%ec%83%81%ed%83%9c-%ec%b6%94%ec%a0%81 aria-label="Socket.IO로 연결 상태 추적">Socket.IO로 연결 상태 추적</a></li><li><a href=#%ec%97%b0%ea%b2%b0-%ec%83%81%ed%83%9c%eb%a5%bc-ui%eb%a1%9c-%ec%8b%9c%ea%b0%81%ed%99%94 aria-label="연결 상태를 UI로 시각화">연결 상태를 UI로 시각화</a></li><li><a href=#%ec%9e%ac%ec%97%b0%ea%b2%b0-%eb%a1%9c%ec%a7%81-%eb%b0%8f-%ec%88%98%eb%8f%99-%ec%9e%ac%ec%8b%9c%eb%8f%84 aria-label="재연결 로직 및 수동 재시도">재연결 로직 및 수동 재시도</a></li><li><a href=#%ec%8b%9c%ec%8a%a4%ed%85%9c-%ec%a0%81%ec%9a%a9-%ec%9d%b4%ed%9b%84%ec%9d%98-%eb%b3%80%ed%99%94 aria-label="시스템 적용 이후의 변화">시스템 적용 이후의 변화</a></li><li><a href=#%eb%a7%88%eb%ac%b4%eb%a6%ac%ed%95%98%eb%a9%b0 aria-label=마무리하며>마무리하며</a></li></ul></div></details></div><div class=post-content><h2 id=연결-단계에서-발견된-간헐적-연결-문제>연결 단계에서 발견된 간헐적 연결 문제<a hidden class=anchor aria-hidden=true href=#연결-단계에서-발견된-간헐적-연결-문제>#</a></h2><p>WebRTC는 <code>RTCPeerConnection</code>과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>peerConnection</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>RTCPeerConnection</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>iceServers</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>urls</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;example.google.com:19302&#34;</span> }],
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>onicecandidate</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>event</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>candidate</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>emit</span>(<span style=color:#e6db74>&#34;ice-candidate&#34;</span>, <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>candidate</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>peerConnection</span>
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>createOffer</span>()
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>offer</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>setLocalDescription</span>(<span style=color:#a6e22e>offer</span>))
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>then</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>emit</span>(<span style=color:#e6db74>&#34;offer&#34;</span>, <span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>localDescription</span>);
</span></span><span style=display:flex><span>  });
</span></span></code></pre></div><p>해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:</p><ul><li>영상이 연결되지 않거나 상대가 보이지 않음</li><li>상태 동기화나 메시지 수신이 실패함</li><li>네트워크 문제인지 브라우저 문제인지 식별하기 어려움</li><li>사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌</li></ul><h3 id=-vpn-사용-환경에서의-연결-실패>📌 VPN 사용 환경에서의 연결 실패<a hidden class=anchor aria-hidden=true href=#-vpn-사용-환경에서의-연결-실패>#</a></h3><p>또한 일부 사용자들이 <strong>VPN을 활성화한 상태에서 접속</strong>하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.</p><p>이 경우 STUN 서버가 공인 IP를 제대로 파악하지 못하거나,</p><p>VPN이 <strong>UDP 및 P2P 트래픽을 제한</strong>하는 경우가 많아 ICE candidate 수집 자체가 실패할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// ICE candidate 로그 분석으로 VPN 의심 환경 확인
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>peerConnection</span>.<span style=color:#a6e22e>onicecandidate</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>event</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>candidate</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cand</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>candidate</span>.<span style=color:#a6e22e>candidate</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>cand</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;relay&#34;</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;VPN 또는 제한된 네트워크일 경우 설정에서 VPN 기능을 끄고 사용하시길 권장합니다.&#34;</span>,
</span></span><span style=display:flex><span>      );
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>cand</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#34;host&#34;</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;직접 연결(host candidate)&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;ICE candidate 수집 종료&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>프론트엔드에서는 이를 직접 감지할 수는 없지만,<br><strong>연결 실패 시 &ldquo;VPN이 켜져 있다면 확인해 주세요"라는 안내 메시지를 추가</strong>함으로써<br>사용자 혼란을 줄이는 데 도움이 되었다.</p><p>이 문제를 계기로, <strong>연결 상태에 대한 진단 및 복원 전략</strong>을 설계하게 되었다.</p><hr><h2 id=전략-테스트-영상-연결-시스템-구축>전략: 테스트 영상 연결 시스템 구축<a hidden class=anchor aria-hidden=true href=#전략-테스트-영상-연결-시스템-구축>#</a></h2><p>영상 연결 시작 전, 네트워크 상태를 점검할 수 있는 별도의 <strong>테스트 연결 시스템</strong>을 구축했다.</p><h3 id=목표는-단순했다>목표는 단순했다:<a hidden class=anchor aria-hidden=true href=#목표는-단순했다>#</a></h3><ul><li>사용자 측의 네트워크가 WebRTC 연결에 적합한지 사전 진단</li><li>연결이 정상인지 아닌지를 <strong>눈으로 확인</strong>할 수 있는 구조</li><li>실패 시, 관리자가 사전 대응(재접속 유도, 전화 연결 등)을 할 수 있도록</li></ul><hr><h2 id=socketio로-연결-상태-추적>Socket.IO로 연결 상태 추적<a hidden class=anchor aria-hidden=true href=#socketio로-연결-상태-추적>#</a></h2><p>WebRTC의 연결 여부 자체는 API만으로 감지하기 어렵기 때문에,<br>우리는 WebRTC 연결과 함께 <code>Socket.IO</code>를 통해 연결 상태를 판단했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// useSocket.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>socket</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>io</span>(<span style=color:#a6e22e>SOCKET_URL</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>reconnection</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>reconnectionAttempts</span>: <span style=color:#66d9ef>5</span>, <span style=color:#75715e>// 5회까지 재시도
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>reconnectionDelay</span>: <span style=color:#66d9ef>3000</span>, <span style=color:#75715e>// 3초 간격
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>timeout</span>: <span style=color:#66d9ef>8000</span>, <span style=color:#75715e>// 연결 시도 제한 시간 8초
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>useEffect</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;connect&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;connected&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;disconnect&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;disconnected&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;reconnecting&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;reconnecting&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;connect_error&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;error&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}, []);
</span></span></code></pre></div><p>이 이벤트 흐름을 통해 연결이 끊겼는지, 재시도 중인지, 정상 연결되었는지를 클라이언트에서 실시간으로 인지할 수 있었다.</p><hr><h2 id=연결-상태를-ui로-시각화>연결 상태를 UI로 시각화<a hidden class=anchor aria-hidden=true href=#연결-상태를-ui로-시각화>#</a></h2><p>우리는 단순한 문자열 표시가 아닌, 직관적인 색상 원형 표시를 사용해 네트워크 상태를 표현했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#75715e>// Indicator.tsx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;react&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>styled</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;styled-components&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Status</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;connected&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;reconnecting&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;disconnected&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;error&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IIndicatorTypeProps</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>status</span>: <span style=color:#66d9ef>Status</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>statusColorMap</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>Status</span>, <span style=color:#a6e22e>string</span>&gt; <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>connected</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#4CAF50&#34;</span>, <span style=color:#75715e>// green
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>reconnecting</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#FFEB3B&#34;</span>, <span style=color:#75715e>// yellow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>disconnected</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#F44336&#34;</span>, <span style=color:#75715e>// red
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>error</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#9E9E9E&#34;</span>, <span style=color:#75715e>// gray
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Dot</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>styled</span>.<span style=color:#a6e22e>div</span><span style=color:#f92672>&lt;</span>{ <span style=color:#a6e22e>color</span>: <span style=color:#66d9ef>string</span> }<span style=color:#f92672>&gt;</span><span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  width: 10px;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  height: 10px;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  border-radius: 50%;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  background-color: </span><span style=color:#e6db74>${</span>({ <span style=color:#a6e22e>color</span> <span style=color:#e6db74>}</span><span style=color:#e6db74>) =&gt; color};
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  margin-right: 8px;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Indicator</span>: <span style=color:#66d9ef>React.FC</span>&lt;<span style=color:#f92672>IIndicatorTypeProps</span>&gt; <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>status</span> }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>Dot</span> <span style=color:#a6e22e>color</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>statusColorMap</span>[<span style=color:#a6e22e>status</span>]} /&gt;;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>Indicator</span>;
</span></span></code></pre></div><p>이러한 UI는 사용자 또는 관리자가 한눈에 상황을 파악할 수 있도록 해주었고,<br>사용자에게도 &ldquo;지금 연결이 안 되고 있다"는 명확한 피드백을 제공해 UX 혼란을 줄일 수 있었다.</p><hr><h2 id=재연결-로직-및-수동-재시도>재연결 로직 및 수동 재시도<a hidden class=anchor aria-hidden=true href=#재연결-로직-및-수동-재시도>#</a></h2><p>Socket.IO는 자동 reconnect 기능을 제공하지만,<br>간헐적인 실패에 대비하여 수동 재시도 버튼도 함께 제공했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>status</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;disconnected&#34;</span> <span style=color:#f92672>&amp;&amp;</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>manualReconnect</span>}&gt;<span style=color:#960050;background-color:#1e0010>다시</span> <span style=color:#960050;background-color:#1e0010>연결</span> <span style=color:#960050;background-color:#1e0010>시도</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이때 manualReconnect 함수는 내부적으로 소켓과 WebRTC 스트림을 초기화한 뒤, 화면을 다시 렌더링하며 재연결을 시도했다.</p><hr><h2 id=시스템-적용-이후의-변화>시스템 적용 이후의 변화<a hidden class=anchor aria-hidden=true href=#시스템-적용-이후의-변화>#</a></h2><p>이 테스트 시스템 도입 후, 다음과 같은 개선이 있었다:</p><ul><li>연결 실패율이 감소했고, 실패 시 사전 감지가 가능해짐</li><li>연결 문제에 대한 피드백이 시각적으로 제공되어 UX 혼란이 줄어듦</li><li>담당자와 사용자 모두가 상태 인지 → 대처 흐름을 이해하기 쉬워짐</li></ul><hr><h2 id=마무리하며>마무리하며<a hidden class=anchor aria-hidden=true href=#마무리하며>#</a></h2><p>WebRTC는 네트워크 품질과 연결 상태에 큰 영향을 받는다.<br>특히 해외 사용자 대상의 시스템에서는 환경이 예측 불가했기 때문에,<br>연결 실패 자체보다도 실패했는지 조차 모르는 상황이 더 큰 문제였다.</p><p>Socket.IO와 간단한 연결 UI를 기반으로 한 이 테스트 시스템은<br>WebRTC 인프라를 보완하지 않고도 문제를 조기에 감지하고 대응할 수 있는 프론트엔드 측 해결책이었다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://leeyeonseong.github.io/tech-blog/tags/socket.io/>Socket.io</a></li><li><a href=https://leeyeonseong.github.io/tech-blog/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%95%88%EC%A0%95%EC%84%B1/>네트워크 안정성</a></li></ul><nav class=paginav><a class=prev href=https://leeyeonseong.github.io/tech-blog/articles/context-recoil/><span class=title>« Prev</span><br><span>Context API -> Recoil 성능 개선 과정</span>
</a><a class=next href=https://leeyeonseong.github.io/tech-blog/articles/react-query-migration/><span class=title>Next »</span><br><span>Context API 대신 React Query를 선택한 이유</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://leeyeonseong.github.io/tech-blog/>블로그</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>