<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까? | 블로그</title>
<meta name=keywords content="Socket.io,네트워크 안정성"><meta name=description content="영상 연결 시스템을 운영하면서 가장 중요하게 다가온 이슈는 실시간 연결의 안정성이었다.
특히 네트워크 환경이 불안정한 지역에서는 WebRTC 연결이 실패하거나, 연결되더라도 영상이 나타나지 않는 경우가 간헐적으로 발생했다.
실시간 연결 도중의 끊김도 문제였지만, 초기 연결 자체가 되지 않는 상황은 더 치명적이었다.

연결 단계에서 발견된 간헐적 연결 문제
WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.
우리는 별도의 TURN 인프라 없이, 공용 STUN 서버만을 사용해 직접 연결(P2P)을 시도했다.
해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:"><meta name=author content><link rel=canonical href=https://leeyeonseong.github.io/tech-blog/articles/socket-issue/><link crossorigin=anonymous href=/tech-blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://leeyeonseong.github.io/tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://leeyeonseong.github.io/tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leeyeonseong.github.io/tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://leeyeonseong.github.io/tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://leeyeonseong.github.io/tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://leeyeonseong.github.io/tech-blog/articles/socket-issue/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://leeyeonseong.github.io/tech-blog/articles/socket-issue/"><meta property="og:site_name" content="블로그"><meta property="og:title" content="해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?"><meta property="og:description" content="영상 연결 시스템을 운영하면서 가장 중요하게 다가온 이슈는 실시간 연결의 안정성이었다.
특히 네트워크 환경이 불안정한 지역에서는 WebRTC 연결이 실패하거나, 연결되더라도 영상이 나타나지 않는 경우가 간헐적으로 발생했다.
실시간 연결 도중의 끊김도 문제였지만, 초기 연결 자체가 되지 않는 상황은 더 치명적이었다.
연결 단계에서 발견된 간헐적 연결 문제 WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.
우리는 별도의 TURN 인프라 없이, 공용 STUN 서버만을 사용해 직접 연결(P2P)을 시도했다.
해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2023-07-23T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-23T00:00:00+00:00"><meta property="article:tag" content="Socket.io"><meta property="article:tag" content="네트워크 안정성"><meta name=twitter:card content="summary"><meta name=twitter:title content="해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?"><meta name=twitter:description content="영상 연결 시스템을 운영하면서 가장 중요하게 다가온 이슈는 실시간 연결의 안정성이었다.
특히 네트워크 환경이 불안정한 지역에서는 WebRTC 연결이 실패하거나, 연결되더라도 영상이 나타나지 않는 경우가 간헐적으로 발생했다.
실시간 연결 도중의 끊김도 문제였지만, 초기 연결 자체가 되지 않는 상황은 더 치명적이었다.

연결 단계에서 발견된 간헐적 연결 문제
WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.
우리는 별도의 TURN 인프라 없이, 공용 STUN 서버만을 사용해 직접 연결(P2P)을 시도했다.
해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://leeyeonseong.github.io/tech-blog/articles/"},{"@type":"ListItem","position":2,"name":"해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?","item":"https://leeyeonseong.github.io/tech-blog/articles/socket-issue/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?","name":"해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?","description":"영상 연결 시스템을 운영하면서 가장 중요하게 다가온 이슈는 실시간 연결의 안정성이었다.\n특히 네트워크 환경이 불안정한 지역에서는 WebRTC 연결이 실패하거나, 연결되더라도 영상이 나타나지 않는 경우가 간헐적으로 발생했다.\n실시간 연결 도중의 끊김도 문제였지만, 초기 연결 자체가 되지 않는 상황은 더 치명적이었다.\n연결 단계에서 발견된 간헐적 연결 문제 WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.\n우리는 별도의 TURN 인프라 없이, 공용 STUN 서버만을 사용해 직접 연결(P2P)을 시도했다.\n해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:\n","keywords":["Socket.io","네트워크 안정성"],"articleBody":"영상 연결 시스템을 운영하면서 가장 중요하게 다가온 이슈는 실시간 연결의 안정성이었다.\n특히 네트워크 환경이 불안정한 지역에서는 WebRTC 연결이 실패하거나, 연결되더라도 영상이 나타나지 않는 경우가 간헐적으로 발생했다.\n실시간 연결 도중의 끊김도 문제였지만, 초기 연결 자체가 되지 않는 상황은 더 치명적이었다.\n연결 단계에서 발견된 간헐적 연결 문제 WebRTC는 RTCPeerConnection과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.\n우리는 별도의 TURN 인프라 없이, 공용 STUN 서버만을 사용해 직접 연결(P2P)을 시도했다.\n해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:\n영상이 연결되지 않거나 상대가 보이지 않음 상태 동기화나 메시지 수신이 실패함 네트워크 문제인지 브라우저 문제인지 식별하기 어려움 사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌 이 문제를 계기로, 연결 상태에 대한 진단 및 복원 전략을 설계하게 되었다.\n전략: 테스트 영상 연결 시스템 구축 영상 연결 시작 전, 네트워크 상태를 점검할 수 있는 별도의 테스트 연결 시스템을 구축했다.\n목표는 단순했다: 사용자 측의 네트워크가 WebRTC 연결에 적합한지 사전 진단 연결이 정상인지 아닌지를 눈으로 확인할 수 있는 구조 실패 시, 관리자가 사전 대응(재접속 유도, 전화 연결 등)을 할 수 있도록 Socket.IO로 연결 상태 추적 WebRTC의 연결 여부 자체는 API만으로 감지하기 어렵기 때문에,\n우리는 WebRTC 연결과 함께 Socket.IO를 통해 연결 상태를 판단했다.\n클라이언트 코드 예시: // useSocket.ts const socket = io(SOCKET_URL, { reconnection: true, reconnectionAttempts: 5, // 5회까지 재시도 reconnectionDelay: 3000, // 3초 간격 timeout: 8000, // 연결 시도 제한 시간 8초 }); useEffect(() =\u003e { socket.on(\"connect\", () =\u003e { setStatus(\"connected\"); }); socket.on(\"disconnect\", () =\u003e { setStatus(\"disconnected\"); }); socket.on(\"reconnecting\", () =\u003e { setStatus(\"reconnecting\"); }); socket.on(\"connect_error\", () =\u003e { setStatus(\"error\"); }); }, []); 이 이벤트 흐름을 통해 연결이 끊겼는지, 재시도 중인지, 정상 연결되었는지를 클라이언트에서 실시간으로 인지할 수 있었다.\n연결 상태를 UI로 시각화 우리는 단순한 문자열 표시가 아닌, 직관적인 색상 원형 표시를 사용해 네트워크 상태를 표현했다.\n// Indicator.tsx import React from \"react\"; import styled from \"styled-components\"; type Status = \"connected\" | \"reconnecting\" | \"disconnected\" | \"error\"; interface IIndicatorTypeProps { status: Status; } const statusColorMap: Record\u003cStatus, string\u003e = { connected: \"#4CAF50\", // green reconnecting: \"#FFEB3B\", // yellow disconnected: \"#F44336\", // red error: \"#9E9E9E\", // gray }; const Dot = styled.div\u003c{ color: string }\u003e` width: 10px; height: 10px; border-radius: 50%; background-color: ${({ color }) =\u003e color}; margin-right: 8px; `; const Indicator: React.FC\u003cIIndicatorTypeProps\u003e = ({ status }) =\u003e { return \u003cDot color={statusColorMap[status]} /\u003e; }; export default Indicator; 이러한 UI는 사용자 또는 관리자가 한눈에 상황을 파악할 수 있도록 해주었고, 사용자에게도 “지금 연결이 안 되고 있다\"는 명확한 피드백을 제공해 UX 혼란을 줄일 수 있었다.\n재연결 로직 및 수동 재시도 Socket.IO는 자동 reconnect 기능을 제공하지만, 간헐적인 실패에 대비하여 수동 재시도 버튼도 함께 제공했다.\n{ status === \"disconnected\" \u0026\u0026 ( \u003cbutton onClick={manualReconnect}\u003e다시 연결 시도\u003c/button\u003e ); } 이때 manualReconnect 함수는 내부적으로 소켓과 WebRTC 스트림을 초기화한 뒤, 화면을 다시 렌더링하며 재연결을 시도했다.\n진료 흐름에 미친 영향 이 테스트 시스템 도입 후, 다음과 같은 개선이 있었다:\n진료 전 연결 실패율이 눈에 띄게 줄어듦 연결 문제 발생 시, 영상 연결 시작 전에 문제를 사전에 인지 가능 UX 혼란 최소화 → 고객 만족도 향상 마무리하며 WebRTC는 네트워크 품질과 연결 상태에 큰 영향을 받는다. 특히 해외 사용자 대상의 시스템에서는 환경이 예측 불가했기 때문에, 연결 실패 자체보다도 실패했는지조차 모르는 상황이 더 큰 문제였다.\nSocket.IO와 간단한 연결 UI를 기반으로 한 이 테스트 시스템은 WebRTC 인프라를 보완하지 않고도 문제를 조기에 감지하고 대응할 수 있는 프론트엔드 측 해결책이었다.\n","wordCount":"527","inLanguage":"en","datePublished":"2023-07-23T00:00:00Z","dateModified":"2023-07-23T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyeonseong.github.io/tech-blog/articles/socket-issue/"},"publisher":{"@type":"Organization","name":"블로그","logo":{"@type":"ImageObject","url":"https://leeyeonseong.github.io/tech-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leeyeonseong.github.io/tech-blog/ accesskey=h title="블로그 (Alt + H)">블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leeyeonseong.github.io/tech-blog/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://leeyeonseong.github.io/tech-blog/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?</h1><div class=post-meta><span title='2023-07-23 00:00:00 +0000 UTC'>July 23, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%97%b0%ea%b2%b0-%eb%8b%a8%ea%b3%84%ec%97%90%ec%84%9c-%eb%b0%9c%ea%b2%ac%eb%90%9c-%ea%b0%84%ed%97%90%ec%a0%81-%ec%97%b0%ea%b2%b0-%eb%ac%b8%ec%a0%9c aria-label="연결 단계에서 발견된 간헐적 연결 문제">연결 단계에서 발견된 간헐적 연결 문제</a></li><li><a href=#%ec%a0%84%eb%9e%b5-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%98%81%ec%83%81-%ec%97%b0%ea%b2%b0-%ec%8b%9c%ec%8a%a4%ed%85%9c-%ea%b5%ac%ec%b6%95 aria-label="전략: 테스트 영상 연결 시스템 구축">전략: 테스트 영상 연결 시스템 구축</a><ul><li><a href=#%eb%aa%a9%ed%91%9c%eb%8a%94-%eb%8b%a8%ec%88%9c%ed%96%88%eb%8b%a4 aria-label="목표는 단순했다:">목표는 단순했다:</a></li></ul></li><li><a href=#socketio%eb%a1%9c-%ec%97%b0%ea%b2%b0-%ec%83%81%ed%83%9c-%ec%b6%94%ec%a0%81 aria-label="Socket.IO로 연결 상태 추적">Socket.IO로 연결 상태 추적</a><ul><li><a href=#%ed%81%b4%eb%9d%bc%ec%9d%b4%ec%96%b8%ed%8a%b8-%ec%bd%94%eb%93%9c-%ec%98%88%ec%8b%9c aria-label="클라이언트 코드 예시:">클라이언트 코드 예시:</a></li></ul></li><li><a href=#%ec%97%b0%ea%b2%b0-%ec%83%81%ed%83%9c%eb%a5%bc-ui%eb%a1%9c-%ec%8b%9c%ea%b0%81%ed%99%94 aria-label="연결 상태를 UI로 시각화">연결 상태를 UI로 시각화</a></li><li><a href=#%ec%9e%ac%ec%97%b0%ea%b2%b0-%eb%a1%9c%ec%a7%81-%eb%b0%8f-%ec%88%98%eb%8f%99-%ec%9e%ac%ec%8b%9c%eb%8f%84 aria-label="재연결 로직 및 수동 재시도">재연결 로직 및 수동 재시도</a></li><li><a href=#%ec%a7%84%eb%a3%8c-%ed%9d%90%eb%a6%84%ec%97%90-%eb%af%b8%ec%b9%9c-%ec%98%81%ed%96%a5 aria-label="진료 흐름에 미친 영향">진료 흐름에 미친 영향</a></li><li><a href=#%eb%a7%88%eb%ac%b4%eb%a6%ac%ed%95%98%eb%a9%b0 aria-label=마무리하며>마무리하며</a></li></ul></div></details></div><div class=post-content><p>영상 연결 시스템을 운영하면서 가장 중요하게 다가온 이슈는 <strong>실시간 연결의 안정성</strong>이었다.</p><p>특히 네트워크 환경이 불안정한 지역에서는 WebRTC 연결이 실패하거나, 연결되더라도 영상이 나타나지 않는 경우가 <strong>간헐적으로</strong> 발생했다.</p><p>실시간 연결 도중의 끊김도 문제였지만, <strong>초기 연결 자체가 되지 않는 상황은 더 치명적</strong>이었다.</p><hr><h2 id=연결-단계에서-발견된-간헐적-연결-문제>연결 단계에서 발견된 간헐적 연결 문제<a hidden class=anchor aria-hidden=true href=#연결-단계에서-발견된-간헐적-연결-문제>#</a></h2><p>WebRTC는 <code>RTCPeerConnection</code>과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.<br>우리는 별도의 TURN 인프라 없이, 공용 STUN 서버만을 사용해 직접 연결(P2P)을 시도했다.</p><p>해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:</p><ul><li>영상이 연결되지 않거나 상대가 보이지 않음</li><li>상태 동기화나 메시지 수신이 실패함</li><li>네트워크 문제인지 브라우저 문제인지 식별하기 어려움</li><li>사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌</li></ul><p>이 문제를 계기로, <strong>연결 상태에 대한 진단 및 복원 전략</strong>을 설계하게 되었다.</p><h2 id=전략-테스트-영상-연결-시스템-구축>전략: 테스트 영상 연결 시스템 구축<a hidden class=anchor aria-hidden=true href=#전략-테스트-영상-연결-시스템-구축>#</a></h2><p>영상 연결 시작 전, 네트워크 상태를 점검할 수 있는 별도의 <strong>테스트 연결 시스템</strong>을 구축했다.</p><h3 id=목표는-단순했다>목표는 단순했다:<a hidden class=anchor aria-hidden=true href=#목표는-단순했다>#</a></h3><ul><li>사용자 측의 네트워크가 WebRTC 연결에 적합한지 사전 진단</li><li>연결이 정상인지 아닌지를 <strong>눈으로 확인</strong>할 수 있는 구조</li><li>실패 시, 관리자가 사전 대응(재접속 유도, 전화 연결 등)을 할 수 있도록</li></ul><hr><h2 id=socketio로-연결-상태-추적>Socket.IO로 연결 상태 추적<a hidden class=anchor aria-hidden=true href=#socketio로-연결-상태-추적>#</a></h2><p>WebRTC의 연결 여부 자체는 API만으로 감지하기 어렵기 때문에,<br>우리는 WebRTC 연결과 함께 <code>Socket.IO</code>를 통해 연결 상태를 판단했다.</p><h3 id=클라이언트-코드-예시>클라이언트 코드 예시:<a hidden class=anchor aria-hidden=true href=#클라이언트-코드-예시>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// useSocket.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>socket</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>io</span>(<span style=color:#a6e22e>SOCKET_URL</span>, {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>reconnection</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>reconnectionAttempts</span>: <span style=color:#66d9ef>5</span>, <span style=color:#75715e>// 5회까지 재시도
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>reconnectionDelay</span>: <span style=color:#66d9ef>3000</span>, <span style=color:#75715e>// 3초 간격
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>timeout</span>: <span style=color:#66d9ef>8000</span>, <span style=color:#75715e>// 연결 시도 제한 시간 8초
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>useEffect</span>(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;connect&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;connected&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;disconnect&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;disconnected&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;reconnecting&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;reconnecting&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;connect_error&#34;</span>, () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setStatus</span>(<span style=color:#e6db74>&#34;error&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}, []);
</span></span></code></pre></div><p>이 이벤트 흐름을 통해 연결이 끊겼는지, 재시도 중인지, 정상 연결되었는지를 클라이언트에서 실시간으로 인지할 수 있었다.</p><h2 id=연결-상태를-ui로-시각화>연결 상태를 UI로 시각화<a hidden class=anchor aria-hidden=true href=#연결-상태를-ui로-시각화>#</a></h2><p>우리는 단순한 문자열 표시가 아닌, 직관적인 색상 원형 표시를 사용해 네트워크 상태를 표현했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#75715e>// Indicator.tsx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;react&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>styled</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;styled-components&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Status</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;connected&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;reconnecting&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;disconnected&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;error&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IIndicatorTypeProps</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>status</span>: <span style=color:#66d9ef>Status</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>statusColorMap</span>: <span style=color:#66d9ef>Record</span>&lt;<span style=color:#f92672>Status</span>, <span style=color:#a6e22e>string</span>&gt; <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>connected</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#4CAF50&#34;</span>, <span style=color:#75715e>// green
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>reconnecting</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#FFEB3B&#34;</span>, <span style=color:#75715e>// yellow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>disconnected</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#F44336&#34;</span>, <span style=color:#75715e>// red
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>error</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;#9E9E9E&#34;</span>, <span style=color:#75715e>// gray
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Dot</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>styled</span>.<span style=color:#a6e22e>div</span><span style=color:#f92672>&lt;</span>{ <span style=color:#a6e22e>color</span>: <span style=color:#66d9ef>string</span> }<span style=color:#f92672>&gt;</span><span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  width: 10px;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  height: 10px;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  border-radius: 50%;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  background-color: </span><span style=color:#e6db74>${</span>({ <span style=color:#a6e22e>color</span> <span style=color:#e6db74>}</span><span style=color:#e6db74>) =&gt; color};
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  margin-right: 8px;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Indicator</span>: <span style=color:#66d9ef>React.FC</span>&lt;<span style=color:#f92672>IIndicatorTypeProps</span>&gt; <span style=color:#f92672>=</span> ({ <span style=color:#a6e22e>status</span> }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>Dot</span> <span style=color:#a6e22e>color</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>statusColorMap</span>[<span style=color:#a6e22e>status</span>]} /&gt;;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>Indicator</span>;
</span></span></code></pre></div><p>이러한 UI는 사용자 또는 관리자가 한눈에 상황을 파악할 수 있도록 해주었고,
사용자에게도 &ldquo;지금 연결이 안 되고 있다"는 명확한 피드백을 제공해 UX 혼란을 줄일 수 있었다.</p><hr><h2 id=재연결-로직-및-수동-재시도>재연결 로직 및 수동 재시도<a hidden class=anchor aria-hidden=true href=#재연결-로직-및-수동-재시도>#</a></h2><p>Socket.IO는 자동 reconnect 기능을 제공하지만,
간헐적인 실패에 대비하여 수동 재시도 버튼도 함께 제공했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>status</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;disconnected&#34;</span> <span style=color:#f92672>&amp;&amp;</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>manualReconnect</span>}&gt;<span style=color:#960050;background-color:#1e0010>다시</span> <span style=color:#960050;background-color:#1e0010>연결</span> <span style=color:#960050;background-color:#1e0010>시도</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이때 manualReconnect 함수는 내부적으로 소켓과 WebRTC 스트림을 초기화한 뒤,
화면을 다시 렌더링하며 재연결을 시도했다.</p><h2 id=진료-흐름에-미친-영향>진료 흐름에 미친 영향<a hidden class=anchor aria-hidden=true href=#진료-흐름에-미친-영향>#</a></h2><p>이 테스트 시스템 도입 후, 다음과 같은 개선이 있었다:</p><ul><li>진료 전 연결 실패율이 눈에 띄게 줄어듦</li><li>연결 문제 발생 시, 영상 연결 시작 전에 문제를 사전에 인지 가능</li><li>UX 혼란 최소화 → 고객 만족도 향상</li></ul><h2 id=마무리하며>마무리하며<a hidden class=anchor aria-hidden=true href=#마무리하며>#</a></h2><p>WebRTC는 네트워크 품질과 연결 상태에 큰 영향을 받는다.
특히 해외 사용자 대상의 시스템에서는 환경이 예측 불가했기 때문에,
연결 실패 자체보다도 실패했는지조차 모르는 상황이 더 큰 문제였다.</p><p>Socket.IO와 간단한 연결 UI를 기반으로 한 이 테스트 시스템은
WebRTC 인프라를 보완하지 않고도 문제를 조기에 감지하고 대응할 수 있는 프론트엔드 측 해결책이었다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://leeyeonseong.github.io/tech-blog/tags/socket.io/>Socket.io</a></li><li><a href=https://leeyeonseong.github.io/tech-blog/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%95%88%EC%A0%95%EC%84%B1/>네트워크 안정성</a></li></ul><nav class=paginav><a class=prev href=https://leeyeonseong.github.io/tech-blog/articles/react-native-codepush/><span class=title>« Prev</span><br><span>React Native에 CodePush 도입기</span>
</a><a class=next href=https://leeyeonseong.github.io/tech-blog/articles/context-recoil/><span class=title>Next »</span><br><span>Context API -> Recoil 성능 개선 과정</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://leeyeonseong.github.io/tech-blog/>블로그</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>