<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>WebRTC howling ... | 블로그</title>
<meta name=keywords content><meta name=description content="하울링은 왜 생기는가?
하울링은 간단히 말하면, 자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고,
그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.
WebRTC는 getUserMedia로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.

여러 방법을 시도해봤습니다
처음에는 아래와 같은 해결책들을 시도했습니다:

연결 직후 마이크를 자동으로 mute 처리
local stream과 remote stream을 분리해 렌더링
오디오 트랙만 따로 추적해서 제어
<audio muted /> 설정 (그러나 의도대로 안 되는 경우도 많음)

하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다."><meta name=author content><link rel=canonical href=https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/><link crossorigin=anonymous href=/tech-blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://leeyeonseong.github.io/tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://leeyeonseong.github.io/tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leeyeonseong.github.io/tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://leeyeonseong.github.io/tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://leeyeonseong.github.io/tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/"><meta property="og:site_name" content="블로그"><meta property="og:title" content="WebRTC howling ..."><meta property="og:description" content="하울링은 왜 생기는가? 하울링은 간단히 말하면, 자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고,
그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.
WebRTC는 getUserMedia로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.
여러 방법을 시도해봤습니다 처음에는 아래와 같은 해결책들을 시도했습니다:
연결 직후 마이크를 자동으로 mute 처리 local stream과 remote stream을 분리해 렌더링 오디오 트랙만 따로 추적해서 제어 <audio muted /> 설정 (그러나 의도대로 안 되는 경우도 많음) 하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2024-02-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="WebRTC howling ..."><meta name=twitter:description content="하울링은 왜 생기는가?
하울링은 간단히 말하면, 자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고,
그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.
WebRTC는 getUserMedia로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.

여러 방법을 시도해봤습니다
처음에는 아래와 같은 해결책들을 시도했습니다:

연결 직후 마이크를 자동으로 mute 처리
local stream과 remote stream을 분리해 렌더링
오디오 트랙만 따로 추적해서 제어
<audio muted /> 설정 (그러나 의도대로 안 되는 경우도 많음)

하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://leeyeonseong.github.io/tech-blog/articles/"},{"@type":"ListItem","position":2,"name":"WebRTC howling ...","item":"https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WebRTC howling ...","name":"WebRTC howling ...","description":"하울링은 왜 생기는가? 하울링은 간단히 말하면, 자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고,\n그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.\nWebRTC는 getUserMedia로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.\n여러 방법을 시도해봤습니다 처음에는 아래와 같은 해결책들을 시도했습니다:\n연결 직후 마이크를 자동으로 mute 처리 local stream과 remote stream을 분리해 렌더링 오디오 트랙만 따로 추적해서 제어 \u0026lt;audio muted /\u0026gt; 설정 (그러나 의도대로 안 되는 경우도 많음) 하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다.\n","keywords":[],"articleBody":"하울링은 왜 생기는가? 하울링은 간단히 말하면, 자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고,\n그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.\nWebRTC는 getUserMedia로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.\n여러 방법을 시도해봤습니다 처음에는 아래와 같은 해결책들을 시도했습니다:\n연결 직후 마이크를 자동으로 mute 처리 local stream과 remote stream을 분리해 렌더링 오디오 트랙만 따로 추적해서 제어 설정 (그러나 의도대로 안 되는 경우도 많음) 하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다.\n실제로 적용 방법 결론적으로 아래 두 가지 조합으로 문제를 대부분 해결할 수 있었습니다.\n1. getUserMedia constraints에 echoCancellation 옵션 추가 브라우저에서 기본 제공하는 오디오 필터 기능을 활용했습니다.\nnavigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, }, video: true, }); 이 옵션을 명시적으로 넣었더니, 브라우저가 하울링을 줄이기 위해 자체적으로 오디오를 필터링해줍니다. 그리고 로컬 오디오 렌더링을 방지하기 위해\nif (remoteUser.id !== localUser.id) { videoElement.srcObject = remoteStream; } 이 조건만 제대로 걸어줘도 자기 목소리를 다시 듣는 상황을 방지할 수 있었고, 하울링도 없어졌습니다.\n마무리하며 WebRTC는 브라우저 환경에 따라 동작 차이가 크고, 작은 설정 하나로 사용자 경험이 크게 달라지기 때문에 하울링 같은 문제는 조기에 잡아두는 게 중요합니다.\n이후에는 Agora SDK로 전환해 더 안정적인 연결 구조를 가져가게 되었지만, WebRTC 기반 구조에서도 기본 설정만 잘 해줘도 충분히 쓸 수 있다는 걸 경험했습니다.\n","wordCount":"206","inLanguage":"en","datePublished":"2024-02-03T00:00:00Z","dateModified":"2024-02-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/"},"publisher":{"@type":"Organization","name":"블로그","logo":{"@type":"ImageObject","url":"https://leeyeonseong.github.io/tech-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leeyeonseong.github.io/tech-blog/ accesskey=h title="블로그 (Alt + H)">블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leeyeonseong.github.io/tech-blog/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://leeyeonseong.github.io/tech-blog/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">WebRTC howling ...</h1><div class=post-meta><span title='2024-02-03 00:00:00 +0000 UTC'>February 3, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ed%95%98%ec%9a%b8%eb%a7%81%ec%9d%80-%ec%99%9c-%ec%83%9d%ea%b8%b0%eb%8a%94%ea%b0%80 aria-label="하울링은 왜 생기는가?">하울링은 왜 생기는가?</a></li><li><a href=#%ec%97%ac%eb%9f%ac-%eb%b0%a9%eb%b2%95%ec%9d%84-%ec%8b%9c%eb%8f%84%ed%95%b4%eb%b4%a4%ec%8a%b5%eb%8b%88%eb%8b%a4 aria-label="여러 방법을 시도해봤습니다">여러 방법을 시도해봤습니다</a></li><li><a href=#%ec%8b%a4%ec%a0%9c%eb%a1%9c-%ec%a0%81%ec%9a%a9-%eb%b0%a9%eb%b2%95 aria-label="실제로 적용 방법">실제로 적용 방법</a><ul><li><a href=#1-getusermedia-constraints%ec%97%90-echocancellation-%ec%98%b5%ec%85%98-%ec%b6%94%ea%b0%80 aria-label="1. getUserMedia constraints에 echoCancellation 옵션 추가">1. getUserMedia constraints에 echoCancellation 옵션 추가</a></li></ul></li><li><a href=#%eb%a7%88%eb%ac%b4%eb%a6%ac%ed%95%98%eb%a9%b0 aria-label=마무리하며>마무리하며</a></li></ul></div></details></div><div class=post-content><h2 id=하울링은-왜-생기는가>하울링은 왜 생기는가?<a hidden class=anchor aria-hidden=true href=#하울링은-왜-생기는가>#</a></h2><p>하울링은 간단히 말하면, <strong>자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고</strong>,</p><p>그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.</p><p>WebRTC는 <code>getUserMedia</code>로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.</p><hr><h2 id=여러-방법을-시도해봤습니다>여러 방법을 시도해봤습니다<a hidden class=anchor aria-hidden=true href=#여러-방법을-시도해봤습니다>#</a></h2><p>처음에는 아래와 같은 해결책들을 시도했습니다:</p><ul><li>연결 직후 마이크를 자동으로 mute 처리</li><li>local stream과 remote stream을 분리해 렌더링</li><li>오디오 트랙만 따로 추적해서 제어</li><li><code>&lt;audio muted /></code> 설정 (그러나 의도대로 안 되는 경우도 많음)</li></ul><p>하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다.</p><h2 id=실제로-적용-방법>실제로 적용 방법<a hidden class=anchor aria-hidden=true href=#실제로-적용-방법>#</a></h2><p>결론적으로 아래 두 가지 조합으로 문제를 대부분 해결할 수 있었습니다.</p><h3 id=1-getusermedia-constraints에-echocancellation-옵션-추가>1. <code>getUserMedia</code> constraints에 echoCancellation 옵션 추가<a hidden class=anchor aria-hidden=true href=#1-getusermedia-constraints에-echocancellation-옵션-추가>#</a></h3><p>브라우저에서 기본 제공하는 오디오 필터 기능을 활용했습니다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>mediaDevices</span>.<span style=color:#a6e22e>getUserMedia</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>audio</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>echoCancellation</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noiseSuppression</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>video</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>이 옵션을 명시적으로 넣었더니, 브라우저가 하울링을 줄이기 위해 자체적으로 오디오를 필터링해줍니다. 그리고 로컬 오디오 렌더링을 방지하기 위해</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>remoteUser</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>localUser</span>.<span style=color:#a6e22e>id</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>videoElement</span>.<span style=color:#a6e22e>srcObject</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>remoteStream</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 조건만 제대로 걸어줘도
자기 목소리를 다시 듣는 상황을 방지할 수 있었고, 하울링도 없어졌습니다.</p><hr><h2 id=마무리하며>마무리하며<a hidden class=anchor aria-hidden=true href=#마무리하며>#</a></h2><p>WebRTC는 브라우저 환경에 따라 동작 차이가 크고,
작은 설정 하나로 사용자 경험이 크게 달라지기 때문에
하울링 같은 문제는 조기에 잡아두는 게 중요합니다.</p><p>이후에는 Agora SDK로 전환해 더 안정적인 연결 구조를 가져가게 되었지만,
WebRTC 기반 구조에서도 기본 설정만 잘 해줘도 충분히 쓸 수 있다는 걸 경험했습니다.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/><span class=title>« Prev</span><br><span>react-virtualized로 대용량 리스트 렌더링 최적화하기</span>
</a><a class=next href=https://leeyeonseong.github.io/tech-blog/articles/react-native-codepush/><span class=title>Next »</span><br><span>React Native에 CodePush 도입기</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://leeyeonseong.github.io/tech-blog/>블로그</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>