<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>react-virtualized로 대용량 리스트 렌더링 최적화하기 | everyeon</title>
<meta name=keywords content><meta name=description content="react-virtualized를 적용하며 성능 개선한 내용을 정리해보려고 한다.
단순히 가상화 리스트를 도입한 것에서 그치지 않고, Chrome 개발자 도구를 통해 메모리 구조와 GC 작동 방식까지 추적하며 성능 최적화가 실제로 어떤 효과를 가져오는지를 직접 비교해봤습니다.

대용량 리스트 렌더링, 문제는 성능과 메모리였다
프로젝트에서 최대 10만개에 이르는 오디오 스크립트 데이터를 한 번에 보여줘야 했습니다..
레거시 프로젝트에선 단순히 .map()을 통해 리스트를 출력하는 방식으로 개발 되었었지만, 예상대로 다음과 같은 문제가 있었다.

스크롤 시 끊김 현상 발생
DevTools의 JavasScript Heap 메모리 지속 증가
사용자 경험(UX) 저하

이런 상황이 존재하여 성능 최적화 및 리스트 가상화 도입을 하게 되었다."><meta name=author content><link rel=canonical href=https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/><link crossorigin=anonymous href=/tech-blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://leeyeonseong.github.io/tech-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://leeyeonseong.github.io/tech-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://leeyeonseong.github.io/tech-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://leeyeonseong.github.io/tech-blog/apple-touch-icon.png><link rel=mask-icon href=https://leeyeonseong.github.io/tech-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/"><meta property="og:site_name" content="everyeon"><meta property="og:title" content="react-virtualized로 대용량 리스트 렌더링 최적화하기"><meta property="og:description" content="react-virtualized를 적용하며 성능 개선한 내용을 정리해보려고 한다.
단순히 가상화 리스트를 도입한 것에서 그치지 않고, Chrome 개발자 도구를 통해 메모리 구조와 GC 작동 방식까지 추적하며 성능 최적화가 실제로 어떤 효과를 가져오는지를 직접 비교해봤습니다.
대용량 리스트 렌더링, 문제는 성능과 메모리였다 프로젝트에서 최대 10만개에 이르는 오디오 스크립트 데이터를 한 번에 보여줘야 했습니다.. 레거시 프로젝트에선 단순히 .map()을 통해 리스트를 출력하는 방식으로 개발 되었었지만, 예상대로 다음과 같은 문제가 있었다.
스크롤 시 끊김 현상 발생 DevTools의 JavasScript Heap 메모리 지속 증가 사용자 경험(UX) 저하 이런 상황이 존재하여 성능 최적화 및 리스트 가상화 도입을 하게 되었다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2024-04-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="react-virtualized로 대용량 리스트 렌더링 최적화하기"><meta name=twitter:description content="react-virtualized를 적용하며 성능 개선한 내용을 정리해보려고 한다.
단순히 가상화 리스트를 도입한 것에서 그치지 않고, Chrome 개발자 도구를 통해 메모리 구조와 GC 작동 방식까지 추적하며 성능 최적화가 실제로 어떤 효과를 가져오는지를 직접 비교해봤습니다.

대용량 리스트 렌더링, 문제는 성능과 메모리였다
프로젝트에서 최대 10만개에 이르는 오디오 스크립트 데이터를 한 번에 보여줘야 했습니다..
레거시 프로젝트에선 단순히 .map()을 통해 리스트를 출력하는 방식으로 개발 되었었지만, 예상대로 다음과 같은 문제가 있었다.

스크롤 시 끊김 현상 발생
DevTools의 JavasScript Heap 메모리 지속 증가
사용자 경험(UX) 저하

이런 상황이 존재하여 성능 최적화 및 리스트 가상화 도입을 하게 되었다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://leeyeonseong.github.io/tech-blog/articles/"},{"@type":"ListItem","position":2,"name":"react-virtualized로 대용량 리스트 렌더링 최적화하기","item":"https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"react-virtualized로 대용량 리스트 렌더링 최적화하기","name":"react-virtualized로 대용량 리스트 렌더링 최적화하기","description":"react-virtualized를 적용하며 성능 개선한 내용을 정리해보려고 한다.\n단순히 가상화 리스트를 도입한 것에서 그치지 않고, Chrome 개발자 도구를 통해 메모리 구조와 GC 작동 방식까지 추적하며 성능 최적화가 실제로 어떤 효과를 가져오는지를 직접 비교해봤습니다.\n대용량 리스트 렌더링, 문제는 성능과 메모리였다 프로젝트에서 최대 10만개에 이르는 오디오 스크립트 데이터를 한 번에 보여줘야 했습니다.. 레거시 프로젝트에선 단순히 .map()을 통해 리스트를 출력하는 방식으로 개발 되었었지만, 예상대로 다음과 같은 문제가 있었다.\n스크롤 시 끊김 현상 발생 DevTools의 JavasScript Heap 메모리 지속 증가 사용자 경험(UX) 저하 이런 상황이 존재하여 성능 최적화 및 리스트 가상화 도입을 하게 되었다.\n","keywords":[],"articleBody":"react-virtualized를 적용하며 성능 개선한 내용을 정리해보려고 한다.\n단순히 가상화 리스트를 도입한 것에서 그치지 않고, Chrome 개발자 도구를 통해 메모리 구조와 GC 작동 방식까지 추적하며 성능 최적화가 실제로 어떤 효과를 가져오는지를 직접 비교해봤습니다.\n대용량 리스트 렌더링, 문제는 성능과 메모리였다 프로젝트에서 최대 10만개에 이르는 오디오 스크립트 데이터를 한 번에 보여줘야 했습니다.. 레거시 프로젝트에선 단순히 .map()을 통해 리스트를 출력하는 방식으로 개발 되었었지만, 예상대로 다음과 같은 문제가 있었다.\n스크롤 시 끊김 현상 발생 DevTools의 JavasScript Heap 메모리 지속 증가 사용자 경험(UX) 저하 이런 상황이 존재하여 성능 최적화 및 리스트 가상화 도입을 하게 되었다.\n무엇땜에 react-virtualized를 선택했는가? 당시 고민했던 가상화 라이브러리는 두 가지였다:\nreact-virtualized react-window react-window는 더 가볍고 최신 라이브러리이며,\n실제로 다운로드 수나 커뮤니티 트렌드를 보면 아래처럼 요즘 더 많이 사용되고 있다. 사용 할 당시는 react-virtualized 의 다운로드 수가 더 많았습니다.\n다운로드 수를 보고 라이브러리를 선택하지는 않지만, 그 당시 react-virtualized를 선택했다.\n이유는 다음과 같다:\nreact-window는 스타일이 단순한 리스트에 최적화되어 있었고, 테이블 형태의 커스터마이징이 까다로웠다 반면 react-virtualized는 기본적으로 AutoSizer, Table, ScrollSync 등 다양한 컴포넌트가 준비되어 있어서 복잡한 레이아웃에서도 바로 적용하기 수월했다 내가 다루는 UI는 단순 리스트가 아니라 스크립트, 체크박스, 오디오 버튼, 텍스트 수정 기능까지 포함된 테이블 구조였고, 이런 상황에서는 react-virtualized가 훨씬 빠르게 결과를 낼 수 있었다.\nreact-virtualized 내부적으로 어떤 방식으로 동작하는가 react-virtualized는 기본적으로 scrollTop과 containerSize를 기준으로\n현재 화면에서 보여야 하는 row의 시작 인덱스와 끝 인덱스를 계산한다.\n아래는 react-virtualized/source/Grid/utils/CellSizeAndPositionManager.js 에 존재하는 내부 로직 일부이다:\ngetVisibleCellRange({ containerSize, offset }) { const totalCells = this._cellCount; let startIndex = this._findNearestCell(offset); const maxOffset = offset + containerSize - 1; let stopIndex = startIndex; while ( stopIndex \u003c totalCells - 1 \u0026\u0026 this.getSizeAndPositionOfCell(stopIndex).offset + this.getSizeAndPositionOfCell(stopIndex).size \u003c maxOffset ) { stopIndex++; } return { start: startIndex, stop: stopIndex, }; } 이 함수는 다음과 같은 흐름으로 작동한다:\n현재 스크롤 위치(offset)에 가장 가까운 셀 인덱스를 계산한다. 해당 셀부터 시작해 화면 끝까지 보이는 셀을 stopIndex로 지정한다. 이 범위에 해당하는 셀만 DOM에 mount하고, 나머지는 렌더링하지 않는다. 실제로 적용한 방식 내가 적용한 구조는 아래와 같다. 핵심은 AutoSizer와 List를 조합해 가시 영역만 렌더링하도록 구성하는 것이다.\nconst Table = (displayedList: IData) =\u003e { return ( \u003c\u003e {displayedList.length ? ( \u003cAutoSizer\u003e {({ height, width }) =\u003e { return ( \u003cList key={displayedList.map((item) =\u003e item.id).join(\",\")} height={height} width={width} rowCount={displayedList.length} rowRenderer={rowRenderer} rowHeight={calculateRowHeight} /\u003e ); }} \u003c/AutoSizer\u003e ) : ( \u003cEmptyContainer\u003e요청된 리스트가 없습니다.\u003c/EmptyContainer\u003e )} \u003c/\u003e ); }; rowHeight는 텍스트 길이에 따라 동적으로 계산되도록 구성했고 rowRenderer는 각각의 스크립트, 체크박스, 오디오 버튼, 수정 가능한 textarea 등을 렌더링하도록 커스터마이징했다 기존 .map() 기반 리스트와 비교해보면, 렌더링 구조를 바꾼 것만으로도 스크롤 성능과 메모리 사용량이 확연히 달라졌다.\n메모리 사용량 변화 Chrome DevTools의 Performance 탭을 이용해 스크롤 중 JS Heap 메모리를 측정해보았다.\nmap() 렌더링 기반 사용 시 JS Heap: 46.8MB → 47.5MB GC(Garbage Collection) 발생 없음 메모리가 계속 유지되며 누적 (우 상향 그래프) 프리징, 렉 발생 가능성 존재 react-virtualized 적용 시 JS Heap: 16.9MB → 최대 70.8MB까지 증가 후 회수 GC (Garbage Collection) 주기적으로 발생 메모리가 안정적으로 회수되며 일정하게 유지 (계단 식 그래프) 적용 후 스크롤 변화 가상화 전에는 몇천 건 이상의 데이터에서 스크롤이 누적될수록 브라우저가 버벅였지만, 적용 후에는 View Section만 렌더링 되어 수만 건도 부드럽게 스크롤 되는걸 볼 수 있습니다. 위의 테이터는 실 데이터가 아닌 dummy 데이터 입니다.\n메모리를 아낄 수 있었던 진짜 이유는? 단순히 DOM 수를 줄인 것만으로도 이렇게 큰 차이가 났을까?\n그렇다면 단순히 렌더링된 DOM 수를 줄였다는 이유만으로 왜 JS Heap 메모리 사용량과 GC 작동이 개선되었을까?\n이 질문에 답하려면 JavaScript의 메모리 구조와 GC 동작 방식을 함께 살펴봐야 한다.\nJavaScript 엔진은 메모리를 크게 Stack과 Heap으로 나눈다. Stack: 고정된 크기의 원시 값 (number, string 등) Heap: 동적으로 할당되는 객체, 배열, DOM 등 대부분의 UI 상태나 데이터, 렌더링되는 컴포넌트들은 Heap에 저장된다.\nGC(Garbage Collector)는 언제 발생하는가?\nlet data = { value: \"스크립트\" }; data = null; 위처럼 더 이상 참조되지 않는 객체는 GC(Garbage Collector)가 Mark-and-Sweep 알고리즘으로 판단해 해당 메모리를 제거하게 된다.\n하지만, .map()으로 생성된 수만 개의 DOM이 계속 참조되고 있다면? GC(Garbage Collector)는 작동하지 않는다. 이로 인해 메모리 누수가 발생하게 됩니다.\nreact-virtualized는 필요한 DOM만 메모리에 유지하고, 나머지는 unmount되기 때문에 GC(Garbage Collector)가 잘 작동할 수 있는 구조가 된다.\n마무리하며 이번 작업을 통해 성능 병목을 해결하는 과정은 단순히 라이브러리 하나를 도입하는 것이 아니라,\n왜 이 기술을 선택해야 했는지, 실제로 어떤 효과를 가져오는지,\n그리고 어떻게 작동하는지를 이해하는 과정이 동반되어야 한다는 사실을 다시금 느꼈다.\n앞으로도 성능 문제가 생긴다면 단순히 새로운 기술을 시도하기보다,\n문제를 측정하고, 원인을 파악하고, 내부 구조를 이해한 뒤 설계하는 습관을 유지하고 싶다.\n그 과정 속에서 나의 기준도 함께 성장할 수 있기를 바란다.\n","wordCount":"695","inLanguage":"en","datePublished":"2024-04-02T00:00:00Z","dateModified":"2024-04-02T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/"},"publisher":{"@type":"Organization","name":"everyeon","logo":{"@type":"ImageObject","url":"https://leeyeonseong.github.io/tech-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://leeyeonseong.github.io/tech-blog/ accesskey=h title="everyeon (Alt + H)">everyeon</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://leeyeonseong.github.io/tech-blog/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://leeyeonseong.github.io/tech-blog/about/ title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">react-virtualized로 대용량 리스트 렌더링 최적화하기</h1><div class=post-meta><span title='2024-04-02 00:00:00 +0000 UTC'>April 2, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%8c%80%ec%9a%a9%eb%9f%89-%eb%a6%ac%ec%8a%a4%ed%8a%b8-%eb%a0%8c%eb%8d%94%eb%a7%81-%eb%ac%b8%ec%a0%9c%eb%8a%94-%ec%84%b1%eb%8a%a5%ea%b3%bc-%eb%a9%94%eb%aa%a8%eb%a6%ac%ec%98%80%eb%8b%a4 aria-label="대용량 리스트 렌더링, 문제는 성능과 메모리였다">대용량 리스트 렌더링, 문제는 성능과 메모리였다</a></li><li><a href=#%eb%ac%b4%ec%97%87%eb%95%9c%ec%97%90-react-virtualized%eb%a5%bc-%ec%84%a0%ed%83%9d%ed%96%88%eb%8a%94%ea%b0%80 aria-label="무엇땜에 react-virtualized를 선택했는가?">무엇땜에 react-virtualized를 선택했는가?</a></li><li><a href=#react-virtualized-%eb%82%b4%eb%b6%80%ec%a0%81%ec%9c%bc%eb%a1%9c-%ec%96%b4%eb%96%a4-%eb%b0%a9%ec%8b%9d%ec%9c%bc%eb%a1%9c-%eb%8f%99%ec%9e%91%ed%95%98%eb%8a%94%ea%b0%80 aria-label="react-virtualized 내부적으로 어떤 방식으로 동작하는가">react-virtualized 내부적으로 어떤 방식으로 동작하는가</a></li><li><a href=#%ec%8b%a4%ec%a0%9c%eb%a1%9c-%ec%a0%81%ec%9a%a9%ed%95%9c-%eb%b0%a9%ec%8b%9d aria-label="실제로 적용한 방식">실제로 적용한 방식</a></li><li><a href=#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%82%ac%ec%9a%a9%eb%9f%89-%eb%b3%80%ed%99%94 aria-label="메모리 사용량 변화">메모리 사용량 변화</a><ul><li><a href=#map-%eb%a0%8c%eb%8d%94%eb%a7%81-%ea%b8%b0%eb%b0%98-%ec%82%ac%ec%9a%a9-%ec%8b%9c aria-label="map() 렌더링 기반 사용 시">map() 렌더링 기반 사용 시</a></li><li><a href=#react-virtualized-%ec%a0%81%ec%9a%a9-%ec%8b%9c aria-label="react-virtualized 적용 시">react-virtualized 적용 시</a></li><li><a href=#%ec%a0%81%ec%9a%a9-%ed%9b%84-%ec%8a%a4%ed%81%ac%eb%a1%a4-%eb%b3%80%ed%99%94 aria-label="적용 후 스크롤 변화">적용 후 스크롤 변화</a></li></ul></li><li><a href=#%eb%a9%94%eb%aa%a8%eb%a6%ac%eb%a5%bc-%ec%95%84%eb%82%84-%ec%88%98-%ec%9e%88%ec%97%88%eb%8d%98-%ec%a7%84%ec%a7%9c-%ec%9d%b4%ec%9c%a0%eb%8a%94 aria-label="메모리를 아낄 수 있었던 진짜 이유는?">메모리를 아낄 수 있었던 진짜 이유는?</a><ul><li><a href=#javascript-%ec%97%94%ec%a7%84%ec%9d%80-%eb%a9%94%eb%aa%a8%eb%a6%ac%eb%a5%bc-%ed%81%ac%ea%b2%8c-stack%ea%b3%bc-heap%ec%9c%bc%eb%a1%9c-%eb%82%98%eb%88%88%eb%8b%a4 aria-label="JavaScript 엔진은 메모리를 크게 Stack과 Heap으로 나눈다.">JavaScript 엔진은 메모리를 크게 Stack과 Heap으로 나눈다.</a></li></ul></li><li><a href=#%eb%a7%88%eb%ac%b4%eb%a6%ac%ed%95%98%eb%a9%b0 aria-label=마무리하며>마무리하며</a></li></ul></div></details></div><div class=post-content><p>react-virtualized를 적용하며 성능 개선한 내용을 정리해보려고 한다.</p><p>단순히 가상화 리스트를 도입한 것에서 그치지 않고, Chrome 개발자 도구를 통해 메모리 구조와 GC 작동 방식까지 추적하며 성능 최적화가 실제로 어떤 효과를 가져오는지를 직접 비교해봤습니다.</p><hr><h2 id=대용량-리스트-렌더링-문제는-성능과-메모리였다>대용량 리스트 렌더링, 문제는 성능과 메모리였다<a hidden class=anchor aria-hidden=true href=#대용량-리스트-렌더링-문제는-성능과-메모리였다>#</a></h2><p>프로젝트에서 최대 10만개에 이르는 오디오 스크립트 데이터를 한 번에 보여줘야 했습니다..
레거시 프로젝트에선 단순히 <code>.map()</code>을 통해 리스트를 출력하는 방식으로 개발 되었었지만, 예상대로 다음과 같은 문제가 있었다.</p><ul><li>스크롤 시 끊김 현상 발생</li><li>DevTools의 JavasScript Heap 메모리 지속 증가</li><li>사용자 경험(UX) 저하</li></ul><p>이런 상황이 존재하여 성능 최적화 및 리스트 가상화 도입을 하게 되었다.</p><hr><h2 id=무엇땜에-react-virtualized를-선택했는가>무엇땜에 <code>react-virtualized</code>를 선택했는가?<a hidden class=anchor aria-hidden=true href=#무엇땜에-react-virtualized를-선택했는가>#</a></h2><p>당시 고민했던 가상화 라이브러리는 두 가지였다:</p><ul><li><a href=https://github.com/bvaughn/react-virtualized>react-virtualized</a></li><li><a href=https://github.com/bvaughn/react-window>react-window</a></li></ul><p>react-window는 더 가볍고 최신 라이브러리이며,<br>실제로 다운로드 수나 커뮤니티 트렌드를 보면 아래처럼 요즘 더 많이 사용되고 있다.
사용 할 당시는 react-virtualized 의 다운로드 수가 더 많았습니다.</p><p align=center><img src=/tech-blog/assets/images/react-virtualized-trend.png alt="react-virtualized vs window"></p><p>다운로드 수를 보고 라이브러리를 선택하지는 않지만, 그 당시 <strong>react-virtualized를 선택했다</strong>.</p><p>이유는 다음과 같다:</p><ul><li><code>react-window</code>는 스타일이 단순한 리스트에 최적화되어 있었고,</li><li><code>테이블 형태의 커스터마이징</code>이 까다로웠다</li><li>반면 <code>react-virtualized</code>는 기본적으로 <code>AutoSizer</code>, <code>Table</code>, <code>ScrollSync</code> 등 다양한 컴포넌트가 준비되어 있어서</li><li>복잡한 레이아웃에서도 바로 적용하기 수월했다</li></ul><p>내가 다루는 UI는 단순 리스트가 아니라 <strong>스크립트, 체크박스, 오디오 버튼, 텍스트 수정 기능까지 포함된 테이블 구조</strong>였고, 이런 상황에서는 <code>react-virtualized</code>가 훨씬 빠르게 결과를 낼 수 있었다.</p><hr><h2 id=react-virtualized-내부적으로-어떤-방식으로-동작하는가>react-virtualized 내부적으로 어떤 방식으로 동작하는가<a hidden class=anchor aria-hidden=true href=#react-virtualized-내부적으로-어떤-방식으로-동작하는가>#</a></h2><p>react-virtualized는 기본적으로 <code>scrollTop</code>과 <code>containerSize</code>를 기준으로<br>현재 화면에서 보여야 하는 row의 시작 인덱스와 끝 인덱스를 계산한다.</p><p>아래는 <code>react-virtualized/source/Grid/utils/CellSizeAndPositionManager.js</code>
에 존재하는 내부 <a href=https://github.com/bvaughn/react-virtualized/blob/c737715486f724586aee8870ebea1e9efb7b0bfe/source/Grid/utils/CellSizeAndPositionManager.js#L208>로직</a> 일부이다:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>getVisibleCellRange</span>({ <span style=color:#a6e22e>containerSize</span>, <span style=color:#a6e22e>offset</span> }) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>totalCells</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_cellCount</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>startIndex</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_findNearestCell</span>(<span style=color:#a6e22e>offset</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxOffset</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>offset</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>containerSize</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>stopIndex</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>startIndex</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stopIndex</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>totalCells</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getSizeAndPositionOfCell</span>(<span style=color:#a6e22e>stopIndex</span>).<span style=color:#a6e22e>offset</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getSizeAndPositionOfCell</span>(<span style=color:#a6e22e>stopIndex</span>).<span style=color:#a6e22e>size</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>maxOffset</span>
</span></span><span style=display:flex><span>  ) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stopIndex</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>start</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>startIndex</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stop</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>stopIndex</span>,
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 함수는 다음과 같은 흐름으로 작동한다:</p><ul><li>현재 스크롤 위치(offset)에 가장 가까운 셀 인덱스를 계산한다.</li><li>해당 셀부터 시작해 화면 끝까지 보이는 셀을 stopIndex로 지정한다.</li><li>이 범위에 해당하는 셀만 DOM에 mount하고, 나머지는 렌더링하지 않는다.</li></ul><h2 id=실제로-적용한-방식>실제로 적용한 방식<a hidden class=anchor aria-hidden=true href=#실제로-적용한-방식>#</a></h2><p>내가 적용한 구조는 아래와 같다. 핵심은 AutoSizer와 List를 조합해 가시 영역만 렌더링하도록 구성하는 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Table</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>displayedList</span>: <span style=color:#66d9ef>IData</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      {<span style=color:#a6e22e>displayedList</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>?</span> (
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>AutoSizer</span>&gt;
</span></span><span style=display:flex><span>          {({ <span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>width</span> }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>              &lt;<span style=color:#f92672>List</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>displayedList</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>item</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>id</span>).<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34;,&#34;</span>)}
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>height</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>height</span>}
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>width</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>width</span>}
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>rowCount</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>displayedList</span>.<span style=color:#a6e22e>length</span>}
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>rowRenderer</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>rowRenderer</span>}
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>rowHeight</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>calculateRowHeight</span>}
</span></span><span style=display:flex><span>              /&gt;
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>          }}
</span></span><span style=display:flex><span>        &lt;/<span style=color:#f92672>AutoSizer</span>&gt;
</span></span><span style=display:flex><span>      ) <span style=color:#f92672>:</span> (
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>EmptyContainer</span>&gt;<span style=color:#960050;background-color:#1e0010>요청된</span> <span style=color:#960050;background-color:#1e0010>리스트가</span> <span style=color:#960050;background-color:#1e0010>없습니다</span>.&lt;/<span style=color:#f92672>EmptyContainer</span>&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><code>rowHeight</code>는 텍스트 길이에 따라 동적으로 계산되도록 구성했고</li><li><code>rowRenderer</code>는 각각의 스크립트, 체크박스, 오디오 버튼, 수정 가능한 textarea 등을 렌더링하도록 커스터마이징했다</li></ul><p>기존 <code>.map()</code> 기반 리스트와 비교해보면,
렌더링 구조를 바꾼 것만으로도 스크롤 성능과 메모리 사용량이 확연히 달라졌다.</p><hr><h2 id=메모리-사용량-변화>메모리 사용량 변화<a hidden class=anchor aria-hidden=true href=#메모리-사용량-변화>#</a></h2><p>Chrome DevTools의 Performance 탭을 이용해 스크롤 중 JS Heap 메모리를 측정해보았다.</p><h3 id=map-렌더링-기반-사용-시>map() 렌더링 기반 사용 시<a hidden class=anchor aria-hidden=true href=#map-렌더링-기반-사용-시>#</a></h3><p align=center><img src=/tech-blog/assets/images/memory-before.png alt="Heap Before" width=400></p><ul><li>JS Heap: 46.8MB → 47.5MB</li><li>GC(Garbage Collection) 발생 없음</li><li>메모리가 계속 유지되며 누적 (우 상향 그래프)</li><li>프리징, 렉 발생 가능성 존재</li></ul><h3 id=react-virtualized-적용-시>react-virtualized 적용 시<a hidden class=anchor aria-hidden=true href=#react-virtualized-적용-시>#</a></h3><p align=center><img src=/tech-blog/assets/images/memory-after.png alt="Heap After" width=400></p><ul><li>JS Heap: 16.9MB → 최대 70.8MB까지 증가 후 회수</li><li>GC (Garbage Collection) 주기적으로 발생</li><li>메모리가 안정적으로 회수되며 일정하게 유지 (계단 식 그래프)</li></ul><h3 id=적용-후-스크롤-변화>적용 후 스크롤 변화<a hidden class=anchor aria-hidden=true href=#적용-후-스크롤-변화>#</a></h3><p align=center><img src=/tech-blog/assets/images/react-virtualized.gif alt="스크롤 성능 비교" width=600></p>가상화 전에는 몇천 건 이상의 데이터에서 스크롤이 누적될수록 브라우저가 버벅였지만, 적용 후에는 View Section만 렌더링 되어 수만 건도 부드럽게 스크롤 되는걸 볼 수 있습니다.<blockquote><p>위의 테이터는 실 데이터가 아닌 <code>dummy 데이터</code> 입니다.</p></blockquote><hr><h2 id=메모리를-아낄-수-있었던-진짜-이유는>메모리를 아낄 수 있었던 진짜 이유는?<a hidden class=anchor aria-hidden=true href=#메모리를-아낄-수-있었던-진짜-이유는>#</a></h2><p>단순히 DOM 수를 줄인 것만으로도 이렇게 큰 차이가 났을까?</p><p>그렇다면 단순히 렌더링된 DOM 수를 줄였다는 이유만으로
왜 JS Heap 메모리 사용량과 GC 작동이 개선되었을까?</p><blockquote><p>이 질문에 답하려면 <strong>JavaScript의 메모리 구조와 GC 동작 방식</strong>을 함께 살펴봐야 한다.</p></blockquote><h3 id=javascript-엔진은-메모리를-크게-stack과-heap으로-나눈다>JavaScript 엔진은 메모리를 크게 Stack과 Heap으로 나눈다.<a hidden class=anchor aria-hidden=true href=#javascript-엔진은-메모리를-크게-stack과-heap으로-나눈다>#</a></h3><ul><li>Stack: 고정된 크기의 원시 값 (number, string 등)</li><li>Heap: 동적으로 할당되는 객체, 배열, DOM 등</li></ul><p>대부분의 UI 상태나 데이터, 렌더링되는 컴포넌트들은 Heap에 저장된다.</p><p>GC(Garbage Collector)는 언제 발생하는가?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;스크립트&#34;</span> };
</span></span><span style=display:flex><span><span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span></code></pre></div><p>위처럼 더 이상 참조되지 않는 객체는 GC(Garbage Collector)가 <a href=https://javascript.info/garbage-collection>Mark-and-Sweep</a> 알고리즘으로 판단해 해당 메모리를 제거하게 된다.</p><p>하지만, <code>.map()</code>으로 생성된 수만 개의 DOM이 계속 참조되고 있다면? GC(Garbage Collector)는 작동하지 않는다.
이로 인해 메모리 누수가 발생하게 됩니다.</p><p><code>react-virtualized</code>는 필요한 DOM만 메모리에 유지하고, 나머지는 unmount되기 때문에 GC(Garbage Collector)가 잘 작동할 수 있는 구조가 된다.</p><hr><h2 id=마무리하며>마무리하며<a hidden class=anchor aria-hidden=true href=#마무리하며>#</a></h2><p>이번 작업을 통해 성능 병목을 해결하는 과정은 단순히 라이브러리 하나를 도입하는 것이 아니라,<br><strong>왜 이 기술을 선택해야 했는지</strong>, <strong>실제로 어떤 효과를 가져오는지</strong>,<br>그리고 <strong>어떻게 작동하는지를 이해하는 과정이 동반되어야 한다는 사실</strong>을 다시금 느꼈다.</p><p>앞으로도 성능 문제가 생긴다면 단순히 새로운 기술을 시도하기보다,<br><strong>문제를 측정하고, 원인을 파악하고, 내부 구조를 이해한 뒤 설계하는 습관</strong>을 유지하고 싶다.<br>그 과정 속에서 나의 기준도 함께 성장할 수 있기를 바란다.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://leeyeonseong.github.io/tech-blog/articles/hanghea-retrospect/><span class=title>« Prev</span><br><span>기록, 회고, 그리고 앞으로</span>
</a><a class=next href=https://leeyeonseong.github.io/tech-blog/articles/react-agorasdk/><span class=title>Next »</span><br><span>WebRTC에서 Agora로: 왜 Agora SDK를 선택했을까?</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://leeyeonseong.github.io/tech-blog/>everyeon</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>