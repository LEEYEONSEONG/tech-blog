<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>React Query on 블로그</title>
    <link>https://leeyeonseong.github.io/tech-blog/categories/react-query/</link>
    <description>Recent content in React Query on 블로그</description>
    <generator>Hugo -- 0.147.3</generator>
    <language>ko</language>
    <lastBuildDate>Fri, 28 Apr 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://leeyeonseong.github.io/tech-blog/categories/react-query/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Context API 대신 React Query를 선택한 이유</title>
      <link>https://leeyeonseong.github.io/tech-blog/articles/react-query-migration/</link>
      <pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://leeyeonseong.github.io/tech-blog/articles/react-query-migration/</guid>
      <description>&lt;p&gt;이전 글에서 &lt;a href=&#34;https://leeyeonseong.github.io/tech-blog/articles/client-server-state&#34;&gt;Recoil 활용&lt;/a&gt;해 클라이언트 상태를 정리했던 이야기를 남긴 적이 있다.&lt;br&gt;
이번에는 같은 프로젝트 내에서 서버 상태를 다루는 방식에 대해 정리해보려 한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;context-api를-빠르게-선택했던-이유&#34;&gt;Context API를 빠르게 선택했던 이유&lt;/h2&gt;
&lt;p&gt;처음 프로젝트를 시작할 때는 아주 간단한 요구사항만 있었기 때문에, 굳이 무거운 상태 관리 라이브러리를 도입하지 않고 Context API만으로 충분하다고 판단했다.&lt;br&gt;
속도를 중시한 결정이었다. 실제로 빠르게 결과물을 만들 수 있었고, 배포도 문제없이 진행됐다.&lt;/p&gt;
&lt;p&gt;하지만 이후 사업이 확장되며 기능이 하나씩 추가되기 시작했고, 그때부터 context 구조가 무겁게 느껴지기 시작했다.&lt;br&gt;
추가되는 context마다 리렌더링 범위가 넓어졌고, UI 단위에서만 필요한 데이터까지 전역에 얹히는 구조가 되었다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
