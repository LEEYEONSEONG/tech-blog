<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>everyeon</title><link>https://leeyeonseong.github.io/tech-blog/</link><description>Recent content on everyeon</description><generator>Hugo -- 0.147.3</generator><language>ko</language><lastBuildDate>Sun, 08 Jun 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://leeyeonseong.github.io/tech-blog/index.xml" rel="self" type="application/rss+xml"/><item><title>기록, 성찰, 그리고 앞으로</title><link>https://leeyeonseong.github.io/tech-blog/articles/hanghea-retrospect/</link><pubDate>Sun, 08 Jun 2025 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/hanghea-retrospect/</guid><description>&lt;p>항해 &lt;strong>프론트엔드 코스&lt;/strong>를 마치며, 지난 시간을 기록하고 성찰해보고자 합니다.&lt;/p>
&lt;p>이 과정에서 &lt;strong>&lt;em>나&lt;/em>&lt;/strong> 라는 개발자가 어떤 생각을 가지고 시간을 보냈는지,&lt;br>
그리고 앞으로는 어떤 방향으로 나아가고 싶은지를 돌아보는 글입니다.&lt;/p>
&lt;blockquote>
&lt;p>이 글은 어떠한 교육기관을 홍보하기 위한 글이 아닌,&lt;br>
단지 개발자로서 나 자신을 돌아보고, 기록하기 위한 &lt;strong>개인적인 회고&lt;/strong> 입니다.&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="1-항해를-시작할-당시의-나">1. 항해를 시작할 당시의 &lt;strong>&lt;em>나&lt;/em>&lt;/strong>&lt;/h2>
&lt;h3 id="1-1-작년-흔들렸던-시간">1-1. 작년, 흔들렸던 시간&lt;/h3>
&lt;p>작년, 여러모로 많이 힘들었던 시기였다. 외적인 상황도 쉽지 않았지만, 그보다 더 힘들었던 건&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>스스로를 믿는 마음이 점점 작아지고 있었다는 것&lt;/strong>.&lt;/p></description></item><item><title>react-virtualized로 대용량 리스트 렌더링 최적화하기</title><link>https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/</link><pubDate>Tue, 02 Apr 2024 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/react-virtualized/</guid><description>&lt;p>react-virtualized를 적용하며 성능 개선한 내용을 정리해보려고 한다.&lt;/p>
&lt;p>단순히 가상화 리스트를 도입한 것에서 그치지 않고, Chrome 개발자 도구를 통해 메모리 구조와 GC 작동 방식까지 추적하며 성능 최적화가 실제로 어떤 효과를 가져오는지를 직접 비교해봤습니다.&lt;/p>
&lt;hr>
&lt;h2 id="대용량-리스트-렌더링-문제는-성능과-메모리였다">대용량 리스트 렌더링, 문제는 성능과 메모리였다&lt;/h2>
&lt;p>프로젝트에서 최대 10만개에 이르는 오디오 스크립트 데이터를 한 번에 보여줘야 했습니다..
레거시 프로젝트에선 단순히 &lt;code>.map()&lt;/code>을 통해 리스트를 출력하는 방식으로 개발 되었었지만, 예상대로 다음과 같은 문제가 있었다.&lt;/p>
&lt;ul>
&lt;li>스크롤 시 끊김 현상 발생&lt;/li>
&lt;li>DevTools의 JavasScript Heap 메모리 지속 증가&lt;/li>
&lt;li>사용자 경험(UX) 저하&lt;/li>
&lt;/ul>
&lt;p>이런 상황이 존재하여 성능 최적화 및 리스트 가상화 도입을 하게 되었다.&lt;/p></description></item><item><title>WebRTC에서 Agora로: 왜 Agora SDK를 선택했을까?</title><link>https://leeyeonseong.github.io/tech-blog/articles/react-agorasdk/</link><pubDate>Mon, 26 Feb 2024 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/react-agorasdk/</guid><description>&lt;p>실시간 영상 통신을 안정적으로 서비스하는 것은 생각보다 복잡했습니다. 특히 네트워크 환경이 불안정한 해외 사용자를 대상으로 할 경우, 그 어려움은 더 커집니다.&lt;/p>
&lt;p>이번 글에서는 기존 WebRTC 기반 1:1 연결 구조에서 Agora RTC SDK로 전환하게 된 계기와, 그 과정에서 네트워크 품질 측정과 Agora 구조를 소개하고자 합니다.&lt;/p>
&lt;hr>
&lt;h2 id="왜-agora-sdk-였을까">왜 Agora SDK 였을까?&lt;/h2>
&lt;p>기존 WebRTC 기반 연결 구조는 다음과 같은 문제점을 가지고 있었습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>STUN/TURN 서버 인프라 구축 비용 증가&lt;/strong>&lt;/li>
&lt;li>&lt;strong>해외 네트워크 접속 불안정&lt;/strong>&lt;/li>
&lt;li>&lt;strong>연결 전 품질 측정의 어려움&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>👉 &lt;a href="https://leeyeonseong.github.io/tech-blog/articles/socket-issue/">이전 글: 해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?&lt;/a>&lt;/p></description></item><item><title>React Native에 CodePush 도입기</title><link>https://leeyeonseong.github.io/tech-blog/articles/react-native-codepush/</link><pubDate>Sat, 20 Jan 2024 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/react-native-codepush/</guid><description>&lt;p>React Native 기반 앱 프로젝트를 운영하면서, Store 심사 지연으로 인해 &lt;strong>Hotfix 배포나 간단한 UI 수정조차 수일 이상 소요&lt;/strong>되는 일이 잦았습니다.&lt;/p>
&lt;p>특히, 사용자(근로자)에게 주일 마다 피드백을 받아오는 상황에서 잦은 빈도로 업데이트되던 서비스였기 때문에, 이런 병목은 전체 업데이트 일정에 큰 영향을 끼쳤습니다.&lt;/p>
&lt;p>이러한 문제를 해결하기 위해 &lt;strong>CodePush 기반의 무중단 배포 환경&lt;/strong>을 구축했습니다.&lt;/p>
&lt;hr>
&lt;h2 id="왜-codepush를-도입했는가">왜 CodePush를 도입했는가&lt;/h2>
&lt;p>Microsoft에서 제공하는 &lt;a href="https://microsoft.github.io/code-push/">CodePush&lt;/a>는 React Native 앱의 JS 번들만 OTA(Over-the-Air) 방식으로 배포할 수 있도록 해주는 서비스입니다.&lt;/p>
&lt;p>앱을 재설치하거나 스토어 심사를 거치지 않고도 즉각적인 업데이트가 가능한 구조입니다.&lt;/p></description></item><item><title>Next.js에서의 styled-components SSR 이슈와 해결</title><link>https://leeyeonseong.github.io/tech-blog/articles/styled-components-ssr/</link><pubDate>Sun, 23 Jul 2023 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/styled-components-ssr/</guid><description>&lt;p>Next.js 프로젝트(v12)에서 &lt;code>styled-components&lt;/code>를 적용하며 발생한 &lt;strong>스타일 FOUC(Flash of Unstyled Content)&lt;/strong> 문제와 이를 해결한 과정을 정리했습니다.&lt;/p>
&lt;hr>
&lt;h2 id="문제-상황-ssr-환경에서의-스타일-미적용">문제 상황: SSR 환경에서의 스타일 미적용&lt;/h2>
&lt;p>Next.js는 기본적으로 &lt;strong>서버 사이드 렌더링(SSR)&lt;/strong> 을 지원하며, 초기 페이지 로드 시 HTML을 미리 생성해 클라이언트에 전달합니다.&lt;/p>
&lt;p>프로젝트 초기에 아래와 같은 문제가 발생했습니다:&lt;/p>
&lt;ul>
&lt;li>새로고침 시 &lt;strong>스타일이 적용되지 않은 HTML이 먼저 렌더링&lt;/strong>됨&lt;/li>
&lt;li>이후 JS가 로드되면서 styled-components 스타일이 적용됨&lt;/li>
&lt;li>사용자 입장에서 &lt;strong>순간적으로 깨진 UI&lt;/strong>가 보이는 경험을 하게 됨&lt;/li>
&lt;/ul>
&lt;p>이는 흔히 말하는 &lt;strong>FOUC (Flash of Unstyled Content)&lt;/strong> 플리커 현상으로, SSR 환경에서 &lt;code>styled-components&lt;/code>를 사용할 때 자주 발생하는 이슈입니다.&lt;/p></description></item><item><title>Context API -> Recoil 성능 개선 과정</title><link>https://leeyeonseong.github.io/tech-blog/articles/context-recoil/</link><pubDate>Sun, 28 May 2023 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/context-recoil/</guid><description>&lt;p>&lt;a href="https://leeyeonseong.github.io/tech-blog/articles/client-server-state">이전 글&lt;/a>에서 클라이언트 상태와 서버 상태를 분리하는 과정에서&lt;br>
Context API 대신 Recoil을 도입하게 된 이유를 정리한 바 있습니다.&lt;/p>
&lt;p>이번 글에서는 해당 구조가 실제 프로젝트에서 어떻게 적용되었는지,&lt;br>
그리고 Recoil을 사용함으로써 &lt;strong>성능 측면에서 어떤 개선 효과가 있었는지&lt;/strong>를 자세히 공유하려고 합니다.&lt;/p>
&lt;hr>
&lt;h2 id="왜-recoil이-필요했는가">왜 Recoil이 필요했는가&lt;/h2>
&lt;p>이전 글에서 언급했듯이 처음에는 Context API만으로도 충분해 보였습니다. 작은 단위의 상태들을 중앙에서 관리하고, 빠르게 구조화할 수 있었기 때문이다.&lt;/p>
&lt;p>하지만 프로젝트가 커지고 기능이 쌓이면서, Context를 사용하는 컴포넌트가 많아지고, 하나의 값 변경에도 여러 곳에서 렌더링이 발생하기 시작했다.&lt;/p></description></item><item><title>해외 사용자 대상 WebRTC 연결, 어떻게 진단했을까?</title><link>https://leeyeonseong.github.io/tech-blog/articles/socket-issue/</link><pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/socket-issue/</guid><description>&lt;h2 id="연결-단계에서-발견된-간헐적-연결-문제">연결 단계에서 발견된 간헐적 연결 문제&lt;/h2>
&lt;p>WebRTC는 &lt;code>RTCPeerConnection&lt;/code>과 ICE 프로토콜을 통해 두 클라이언트 간 최적 경로를 탐색한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">peerConnection&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">RTCPeerConnection&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">iceServers&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [{ &lt;span style="color:#a6e22e">urls&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;example.google.com:19302&amp;#34;&lt;/span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">peerConnection&lt;/span>.&lt;span style="color:#a6e22e">onicecandidate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">event&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">candidate&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">socket&lt;/span>.&lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ice-candidate&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">candidate&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">peerConnection&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">createOffer&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">offer&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">peerConnection&lt;/span>.&lt;span style="color:#a6e22e">setLocalDescription&lt;/span>(&lt;span style="color:#a6e22e">offer&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">then&lt;/span>(() &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">socket&lt;/span>.&lt;span style="color:#a6e22e">emit&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;offer&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">peerConnection&lt;/span>.&lt;span style="color:#a6e22e">localDescription&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>해외 네트워크 환경을 사용하는 사용자들의 연결 기능에서 다음과 같은 현상이 간헐적으로 발생했다:&lt;/p>
&lt;ul>
&lt;li>영상이 연결되지 않거나 상대가 보이지 않음&lt;/li>
&lt;li>상태 동기화나 메시지 수신이 실패함&lt;/li>
&lt;li>네트워크 문제인지 브라우저 문제인지 식별하기 어려움&lt;/li>
&lt;li>사용자 입장에서는 연결 상태에 대한 명확한 피드백이 없어 혼란을 느낌&lt;/li>
&lt;/ul>
&lt;h3 id="-vpn-사용-환경에서의-연결-실패">📌 VPN 사용 환경에서의 연결 실패&lt;/h3>
&lt;p>또한 일부 사용자들이 &lt;strong>VPN을 활성화한 상태에서 접속&lt;/strong>하는 경우, WebRTC 연결이 실패하는 이슈가 존재했습니다.&lt;/p></description></item><item><title>Context API 대신 React Query를 선택한 이유</title><link>https://leeyeonseong.github.io/tech-blog/articles/react-query-migration/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/react-query-migration/</guid><description>&lt;p>&lt;a href="https://leeyeonseong.github.io/tech-blog/articles/client-server-state">이전 글&lt;/a>에서 Recoil 활용해 클라이언트 상태를 정리했던 이야기를 남긴 적이 있다.&lt;br>
이번에는 같은 프로젝트 내에서 서버 상태를 다루는 방식에 대해 정리해보려 한다.&lt;/p>
&lt;hr>
&lt;h2 id="context-api를-빠르게-선택했던-이유">Context API를 빠르게 선택했던 이유&lt;/h2>
&lt;p>처음 프로젝트를 시작할 때는 아주 간단한 요구사항만 있었기 때문에, 굳이 무거운 상태 관리 라이브러리를 도입하지 않고 Context API만으로 충분하다고 판단했다.&lt;br>
속도를 중시한 결정이었다. 실제로 빠르게 결과물을 만들 수 있었고, 배포도 문제없이 진행됐다.&lt;/p>
&lt;p>하지만 이후 사업이 확장되며 기능이 하나씩 추가되기 시작했고, 그때부터 context 구조가 무겁게 느껴지기 시작했다.&lt;br>
추가되는 context마다 리렌더링 범위가 넓어졌고, UI 단위에서만 필요한 데이터까지 전역에 얹히는 구조가 되었다.&lt;/p></description></item><item><title>WebRTC howling ...</title><link>https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/</link><pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/webrtc-howling/</guid><description>&lt;h2 id="하울링은-왜-생기는가">하울링은 왜 생기는가?&lt;/h2>
&lt;p>하울링은 간단히 말하면, &lt;strong>자신의 마이크에서 들어온 소리가 다시 자신의 스피커로 출력되고&lt;/strong>,&lt;/p>
&lt;p>그게 다시 마이크로 입력되면서 무한 루프를 타는 상황입니다.&lt;/p>
&lt;p>WebRTC는 &lt;code>getUserMedia&lt;/code>로 마이크와 카메라를 활성화하고, 실시간으로 stream을 주고받기 때문에 이런 구조에서는 오디오 루프가 쉽게 생길 수 있습니다.&lt;/p>
&lt;hr>
&lt;h2 id="여러-방법을-시도해봤습니다">여러 방법을 시도해봤습니다&lt;/h2>
&lt;p>처음에는 아래와 같은 해결책들을 시도했습니다:&lt;/p>
&lt;ul>
&lt;li>연결 직후 마이크를 자동으로 mute 처리&lt;/li>
&lt;li>local stream과 remote stream을 분리해 렌더링&lt;/li>
&lt;li>오디오 트랙만 따로 추적해서 제어&lt;/li>
&lt;li>&lt;code>&amp;lt;audio muted /&amp;gt;&lt;/code> 설정 (그러나 의도대로 안 되는 경우도 많음)&lt;/li>
&lt;/ul>
&lt;p>하지만 완벽하게 해결되진 않았고, 상황에 따라 다시 하울링이 발생했습니다.&lt;/p></description></item><item><title>클라이언트와 서버 상태, 왜 분리했는가?</title><link>https://leeyeonseong.github.io/tech-blog/articles/client-server-state/</link><pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/client-server-state/</guid><description>&lt;p>프로젝트를 진행하다 보면 어느 순간 상태가 복잡해지기 시작합니다.&lt;/p>
&lt;p>처음에는 간단한 기능만 있어서 Context API로도 충분해 보였고, 그렇게 빠르게 개발을 시작했습니다.&lt;br>
하지만 기능이 늘어나고 화면과 상태의 연동이 많아지면서, 상태 관리 구조에 대한 고민이 본격적으로 생겼습니다.&lt;/p>
&lt;hr>
&lt;h2 id="context-api에서-발생한-문제">Context API에서 발생한 문제&lt;/h2>
&lt;p>Context는 간단하고 직관적인 구조라는 점에서 좋지만, 하나의 상태가 바뀌면 해당 Provider 아래의 모든 컴포넌트가 함께 리렌더링되는 특성이 있습니다.&lt;/p>
&lt;p>이 문제를 해결하기 위해 Provider를 잘게 쪼개는 방식으로 대응해보기도 했습니다.&lt;br>
하지만 상태가 많아지고, 각각의 의존성을 분리해야 하는 상황에서는 점점 코드가 복잡해졌습니다.&lt;/p></description></item><item><title>WebRTC 사용 중 발생하는 발열과 성능 저하</title><link>https://leeyeonseong.github.io/tech-blog/articles/webrtc-codec/</link><pubDate>Sat, 12 Nov 2022 00:00:00 +0000</pubDate><guid>https://leeyeonseong.github.io/tech-blog/articles/webrtc-codec/</guid><description>&lt;p>영상 연결 시스템을 다루다 보면 브라우저, 특히 모바일에서 영상 연결이 오래 지속될 경우&lt;br>
&lt;strong>발열, 화면 멈춤, 느려짐&lt;/strong> 같은 현상이 발생하는 걸 종종 볼 수 있다.&lt;/p>
&lt;p>그동안은 “기기 문제겠지”라고 넘겼지만,&lt;br>
WebRTC 내부 구조가 어떻게 작동하는지, 왜 그런 문제가 생기는지 공부해보기로 했다.&lt;/p>
&lt;hr>
&lt;h2 id="webrtc에서-발열성능-저하가-발생하는-구조">WebRTC에서 발열/성능 저하가 발생하는 구조&lt;/h2>
&lt;p>찾아보면서 아래와 같은 지점에서 성능 이슈가 발생할 수 있다는 걸 알게 되었다:&lt;/p>
&lt;h3 id="1-getusermedia-호출-시-고해상도-요청">1. getUserMedia 호출 시 고해상도 요청&lt;/h3>
&lt;ul>
&lt;li>기본 요청은 HD(1280x720) 이상일 수 있음&lt;/li>
&lt;li>모바일에서 고해상도는 CPU와 배터리 부담이 큼&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 적절한 해상도 지정
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">navigator&lt;/span>.&lt;span style="color:#a6e22e">mediaDevices&lt;/span>.&lt;span style="color:#a6e22e">getUserMedia&lt;/span>({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">video&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#a6e22e">width&lt;/span>: &lt;span style="color:#66d9ef">640&lt;/span>, &lt;span style="color:#a6e22e">height&lt;/span>: &lt;span style="color:#66d9ef">360&lt;/span>, &lt;span style="color:#a6e22e">frameRate&lt;/span>: &lt;span style="color:#66d9ef">15&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">audio&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>고해상도 + 고 FPS → 모바일 발열 발생 가능성 ↑&lt;/p></description></item></channel></rss>